<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>1991 11 November</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
body {
 margin: 5px 5px 5px 5px;
 background-color: #ffffff;
}
/* ========== Text Styles ========== */
hr { color: #000000}
body, table, span.rvts0 /* Normal text */
{
 font-size: 10pt;
 font-family: 'Arial', 'Helvetica', sans-serif;
 font-style: normal;
 font-weight: normal;
 color: #000000;
 text-decoration: none;
}
span.rvts1 /* Heading */
{
 font-weight: bold;
 color: #0000ff;
}
span.rvts2 /* Subheading */
{
 font-weight: bold;
 color: #000080;
}
span.rvts3 /* Keywords */
{
 font-style: italic;
 color: #800000;
}
a.rvts4, span.rvts4 /* Jump 1 */
{
 color: #008000;
 text-decoration: underline;
}
a.rvts5, span.rvts5 /* Jump 2 */
{
 color: #008000;
 text-decoration: underline;
}
span.rvts6
{
 font-size: 16pt;
 font-family: 'Courier New', 'Courier', monospace;
}
/* ========== Para Styles ========== */
p,ul,ol /* Paragraph Style */
{
 text-align: left;
 text-indent: 0px;
 padding: 0px 0px 0px 0px;
 margin: 0px 0px 0px 0px;
}
.rvps1 /* Centered */
{
 text-align: center;
}
--></style>
</head>
<body style="background-color:#FFFFFF;" >
<p><span class=rvts6>1 &nbsp; Dialog Boxes and Buttons by Larry Quaglia</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Dialogue Boxes and Buttons by Larry Quaglia</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>How to provide a standard set of dialogue boxes and buttons for all of your</span></p>
<p><span class=rvts6>applications.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>One of the primary reasons for the popularity of Microsoft's Windows product</span></p>
<p><span class=rvts6>is the standard user interface it provides for applications. &nbsp;In this respect,</span></p>
<p><span class=rvts6>Windows expands on many of the concepts that were popularized on the Macintosh</span></p>
<p><span class=rvts6>computer. &nbsp;In either of these environments, one application looks like another</span></p>
<p><span class=rvts6>in regards to its user interface. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In Windows, a tug on the FILE menu will almost always give you OPEN, SAVE,</span></p>
<p><span class=rvts6>SAVE AS, and EXIT options. &nbsp;One dialog box looks like another. &nbsp;Nearly every</span></p>
<p><span class=rvts6>application uses the standard Windows File Selector Box. &nbsp;The benefit of this</span></p>
<p><span class=rvts6>standard interface is that once a person learns the ins and outs of one</span></p>
<p><span class=rvts6>application, the learning curve for each successive application is less</span></p>
<p><span class=rvts6>steep. &nbsp;The user can then concentrate on the important parts of utilizing a</span></p>
<p><span class=rvts6>particular program and forget about learning every little idiosyncrasy of the</span></p>
<p><span class=rvts6>interface. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>dBASE IV has already gone a long way toward providing many of these common</span></p>
<p><span class=rvts6>interface guidelines to the developer. &nbsp;One can choose to hard code dBASE III</span></p>
<p><span class=rvts6>PLUS style menus if one chooses, but more often than not, the dBASE IV</span></p>
<p><span class=rvts6>programmer is going to make use of the bar menus and pop-up menus that are</span></p>
<p><span class=rvts6>made available through the dBASE command language. &nbsp;For those items which</span></p>
<p><span class=rvts6>dBASE IV does not have a direct command, we can often create something very</span></p>
<p><span class=rvts6>similar using a specialized procedure or User-Defined Function (UDF). &nbsp;In this</span></p>
<p><span class=rvts6>article, I have outlined a UDF that activates a Windows-style dialog box. &nbsp;For</span></p>
<p><span class=rvts6>those who aren't familiar with that term, a dialog box is a pop-up box that</span></p>
<p><span class=rvts6>displays some message and provides the user with options for responding. &nbsp;In</span></p>
<p><span class=rvts6>Windows, the user responds by selecting a push-button with the mouse or</span></p>
<p><span class=rvts6>keyboard.</span></p>
<p><span class=rvts6>&nbsp;&nbsp;</span></p>
<p><span class=rvts6>This UDF provides for the same functionality within dBASE IV. &nbsp;Using dBASE IV</span></p>
<p><span class=rvts6>windows and bar menus along with some simple shadowing routines, it proves</span></p>
<p><span class=rvts6>quite easy to simulate the Windows dialog box.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>To provide true flexibility, you will be required to pass this function,</span></p>
<p><span class=rvts6>called DIALOG(), some parameters. &nbsp;The syntax for calling the UDF is as</span></p>
<p><span class=rvts6>follows:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;memvar = DIALOG(msg, but_type, bor_sty, def_but, shad, f_col, b_col)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>wherein the names stand for the following:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>msg &nbsp; &nbsp; &nbsp;A character string or memory variable that represents the text you</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;want displayed in the dialog box. &nbsp;</span></p>
<p><span class=rvts6>but_type A numeric expression that indicates which of the predefined button</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;styles and text you wish to use.</span></p>
<p><span class=rvts6>bor_sty &nbsp;A character string. &nbsp;There are only three acceptable values:</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "" (the null string) Ä single line border</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "double" Ä double line border</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "panel" Ä thick border</span></p>
<p><span class=rvts6>def_but &nbsp;A numeric expression that defines the default response button in the</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dialog box (such as the number 2 would make the second button the</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default response). &nbsp;The default response can be selected by just</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hitting the ENTER key when the dialog box is displayed.</span></p>
<p><span class=rvts6>shad &nbsp; &nbsp; Logical expression (.T. or .F.) that designates whether you want the</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dialog box and its push buttons to display shadows for a "3-D" look.</span></p>
<p><span class=rvts6>f_col &nbsp; &nbsp;A character expression representing the foreground color. &nbsp;Must be a</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;valid dBASE color code.</span></p>
<p><span class=rvts6>b_col &nbsp; &nbsp;A character expression representing the background color. &nbsp;Must be a</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid dBASE color code.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>Most of these parameters are self-explanatory. &nbsp;For the "button type"</span></p>
<p><span class=rvts6>parameter, you can pass any value between 0 and 5, thus giving you 6 different</span></p>
<p><span class=rvts6>button styles. &nbsp;You could add more if you so desire, but these six are the</span></p>
<p><span class=rvts6>most common. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This function will return the text of the button selected or the word "ERROR"</span></p>
<p><span class=rvts6>if you passed an illegal value. &nbsp;In addition, the function will sense the</span></p>
<p><span class=rvts6>current video mode and always center the dialog box on the screen. &nbsp;You can</span></p>
<p><span class=rvts6>use the Tab key to move from button to button. &nbsp;In addition, pressing the Alt</span></p>
<p><span class=rvts6>key simultaneously with the first letter of any button will select that</span></p>
<p><span class=rvts6>button. &nbsp;You choose a button by pressing the Enter key. &nbsp;The only real</span></p>
<p><span class=rvts6>limitation of this UDF is that the message that is passed to the dialog box</span></p>
<p><span class=rvts6>can be no longer than 78 characters. &nbsp;The reason for that is obvious (the</span></p>
<p><span class=rvts6>maximum screen width is 80). &nbsp;If you're feeling adventurous, the Dialog()</span></p>
<p><span class=rvts6>function could be modified to accept longer messages, breaking them down and</span></p>
<p><span class=rvts6>putting them on multiple lines.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>You will find that Dialog() will be useful in your own programs in addition to</span></p>
<p><span class=rvts6>calling it from screen forms using the ACCEPT VALUE WHEN option of the screen</span></p>
<p><span class=rvts6>form generator.Note</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Because of anomaly in dBASE IV, you cannot call the DIALOG() function using</span></p>
<p><span class=rvts6>the PERMIT EDIT IF option in a screen form or the WHEN clause of an @.SAY</span></p>
<p><span class=rvts6>command.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION Dialog</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS msg, but_type, border, but_def, shad_box, f_col, b_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;********************************************************************</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* msg &nbsp; &nbsp;= Message that displays within the dialog Box (char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* but_type &nbsp;= Expression that controls the buttons displayed in the box (num)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* border = Border style (char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* but_def &nbsp; = Defines the default button when the box is displayed (num)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* shad_box &nbsp;= .T. - Use Shadow Boxes &nbsp;.F. - Don't Use Shadows (logical)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* f_col &nbsp; &nbsp; = Foreground color. &nbsp;Must be one of the valid color codes</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (W,N,R,G,B,RG,RB,GB, and all the high intensity (+) versions</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of these colors. &nbsp;(char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* b_col &nbsp; &nbsp; = Background color must be one of the valid color codes</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (W,N,R,G,B,RG,RB,GB) (char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;********************************************************************</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* NOTE:</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* You should have a error trapping routine in your main calling program that traps the ERROR()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* function for error 94: WRONG NUMBER OF PARAMETERS.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;SAVE SCREEN TO Backscreen &nbsp; &nbsp; &amp;&amp; Save bacground screen for later restore</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine length of message passed in order to create a large enough box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;msg_len = LEN(TRIM(LTRIM(msg))) +1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Check for too many or incorrect parameters.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE msg_len &gt; 78</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE .NOT. (border = "DOUBLE" .OR. border = "PANEL" .OR. "" = border)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE .NOT. UPPER(f_col) $ "WNRGBRBW+N+R+G+B+RG+RB+GB+"&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE .NOT. UPPER(b_col) $ "WNRGBRB"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Save current color information and set color to user-defined.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;new color = TRIM(UPPER(f_col)) + "/" + TRIM(UPPER(b_col))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* To use the Tab key to move from button to button.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ON KEY LABEL Tab KEYBOARD CHR(4)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Establish three as the maximum number of buttons on a dialog box.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE button[3]</span></p>
<p><span class=rvts6>&nbsp; &nbsp;button[1] = ""</span></p>
<p><span class=rvts6>&nbsp; &nbsp;button[2] = ""</span></p>
<p><span class=rvts6>&nbsp; &nbsp;button[3] = ""</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Establish screen height to properly center dialog box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;num line = IIF(RIGHT(SET("DISP"), 2) = "43", 43, 24)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine the length of passed "message" parameter. &nbsp;If it is long enough,</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* make the dialog box just a little bigger. &nbsp;If it is very short, make the</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* dialog box big enough to accommodate three buttons.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;y = IIF(INT(msg_len) &gt; 30, INT(msg_len / 2) + 2, 24)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;box len = 2 * y</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Set up window for dialog box and determine if shadow parameter</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* is set. &nbsp;If it is set, call shadowing routine.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DEFINE WINDOW Dial_box FROM INT(num line / 2) - 5, 40 - Y TO ;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; INT(num line / 2) + 4, 40 + Y &amp;border</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF shad_box</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO Shadow WITH INT(num line / 2) - 5, 40 - Y, INT(num_line / 2) + 4, 40 + Y, .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE WINDOW Dial_box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;SET COLOR OF NORMAL TO &amp;new_color</span></p>
<p><span class=rvts6>&nbsp; &nbsp;SET COLOR OF MESSAGES TO &amp;new_color</span></p>
<p><span class=rvts6>&nbsp; &nbsp;CLEAR</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine the type of buttons requested and set appropriate parameters.&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* These are representative of some of the ones commonly used in Windows</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* applications. &nbsp;They could easily be modified to suit your own needs.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " &nbsp;OK &nbsp;"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] =" &nbsp; OK &nbsp; "</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2]= " CANCEL "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but type = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " ABORT &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " RETRY &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[3] = " IGNORE "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " &nbsp;YES &nbsp; "</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " &nbsp; NO &nbsp; "</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[3] = " CANCEL "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 4</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " &nbsp;YES &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " &nbsp;NO &nbsp; "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 5</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " RETRY &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " CANCEL "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Get dialog box length to create a bar menu of appropriate size.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Define the bar menu in a do loop. &nbsp;Deactivate the menu upon selection of</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* one of the buttons.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;cnt = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;basex = box_len/(num_but + 1)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DEFINE MENU dial_sel</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE cnt &lt;= num_but</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; style = "DOUBLE"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; pad_name = "PAD " + STR(cnt, 1)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; y_col = (cnt * basex) - (INT(LEN(button[cnt]) / 2))</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DEFINE PAD &amp;pad_name OF dial_sel PROMPT button[cnt] AT 4, y_col</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; * If shadow boxes are set, make sure the buttons appear with shadows as well.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; IF shad_box</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DO SHADOW WITH 3, y_col - 2, 5, y_col + (LEN(button[cnt])) - 1, .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ 3, y_col - 1 TO 5, y_col + (LEN(button[cnt]))</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ON SELECTION PAD &amp;pad_name OF dial_sel DEACTIVATE MENU</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; cnt = cnt +1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine correct location to place the message (i.e., centered in the box).</span></p>
<p><span class=rvts6>&nbsp; &nbsp;msg_loc = INT(box_len / 2) - INT(msg_len / 2)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 1, msg_loc SAY msg</span></p>
<p><span class=rvts6>&nbsp; &nbsp;cnt = 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Move the cursor to the default button as passed by the user.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE cnt &lt; but_def</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; KEYBOARD CHR(4)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; cnt = cnt +1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Activate the dialog box and return the button name</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE MENU Dial_sel</span></p>
<p><span class=rvts6>&nbsp; &nbsp;value = TRIM(LTRIM(PROMPT()))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Deactivate dialog box, restore screen and environment, and get rid of</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* shadow. &nbsp;Here we return the text located on the button. &nbsp;We could easily</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* return the number of the button as well.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DEACTIVATE WINDOW Dial box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF shad box</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO Shadow WITH INT(num_line / 2) - 5, 40 - y, INT(num_line / 2) + 5, 40 + y, .F.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RESTORE SCREEN FROM Backscreen</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ON KEY LABEL TAB</span></p>
<p><span class=rvts6>RETURN value</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE Shadow</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER x1, y1, x2, y2, OnOff</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* If shadowing is on, use the black shadow, otherwise clear box to normal</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* screen colors</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF onoff = .F.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; normal = LEFT(SET("ATTRIBUTES"), AT(",", SET("ATTRIBUTES")) - 1)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; normal = "n+/n"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lnx = x2 + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lny = y2 + 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lndx = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lndy = (y2-y1) / (x2-x1)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Draw Box using @...FILL and appropriate color.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE lnx &lt;&gt; x1 .OR. lny &lt;&gt; y1+2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ lnx, lny FILL TO x2 + 1, y2 + 2 COLOR &amp;normal</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; lnx = IIF(lnx &lt;&gt; x1, lnx - lndx, lnx)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; lny = IIF(lny &lt;&gt; y1 + 2, lny - lndy, lny)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; lny = IIF(lny &lt; y1 + 2, y1 + 2, lny)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>2 &nbsp; Dialog.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION Dialog</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS msg, but_type, border, but_def, shad_box, f_col, b_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;********************************************************************</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* msg &nbsp; &nbsp;= Message that displays within the dialog Box (char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* but_type &nbsp;= Expression that controls the buttons displayed in the box (num)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* border = Border style (char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* but_def &nbsp; = Defines the default button when the box is displayed (num)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* shad_box &nbsp;= .T. - Use Shadow Boxes &nbsp;.F. - Don't Use Shadows (logical)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* f_col &nbsp; &nbsp; = Foreground color. &nbsp;Must be one of the valid color codes</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (W,N,R,G,B,RG,RB,GB, and all the high intensity (+) versions</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of these colors. &nbsp;(char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* b_col &nbsp; &nbsp; = Background color must be one of the valid color codes</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (W,N,R,G,B,RG,RB,GB) (char)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;********************************************************************</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* NOTE:</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* You should have a error trapping routine in your main calling program that traps the ERROR()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* function for error 94: WRONG NUMBER OF PARAMETERS.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;SAVE SCREEN TO Backscreen &nbsp; &nbsp; &amp;&amp; Save bacground screen for later restore</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine length of message passed in order to create a large enough box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;msg_len = LEN(TRIM(LTRIM(msg))) +1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Check for too many or incorrect parameters.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE msg_len &gt; 78</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE .NOT. (border = "DOUBLE" .OR. border = "PANEL" .OR. "" = border)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE .NOT. UPPER(f_col) $ "WNRGBRBW+N+R+G+B+RG+RB+GB+"&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE .NOT. UPPER(b_col) $ "WNRGBRB"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN "ERROR"&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Save current color information and set color to user-defined.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;new color = TRIM(UPPER(f_col)) + "/" + TRIM(UPPER(b_col))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* To use the Tab key to move from button to button.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ON KEY LABEL Tab KEYBOARD CHR(4)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Establish three as the maximum number of buttons on a dialog box.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE button[3]</span></p>
<p><span class=rvts6>&nbsp; &nbsp;button[1] = ""</span></p>
<p><span class=rvts6>&nbsp; &nbsp;button[2] = ""</span></p>
<p><span class=rvts6>&nbsp; &nbsp;button[3] = ""</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Establish screen height to properly center dialog box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;num line = IIF(RIGHT(SET("DISP"), 2) = "43", 43, 24)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine the length of passed "message" parameter. &nbsp;If it is long enough,</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* make the dialog box just a little bigger. &nbsp;If it is very short, make the</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* dialog box big enough to accommodate three buttons.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;y = IIF(INT(msg_len) &gt; 30, INT(msg_len / 2) + 2, 24)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;box len = 2 * y</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Set up window for dialog box and determine if shadow parameter</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* is set. &nbsp;If it is set, call shadowing routine.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DEFINE WINDOW Dial_box FROM INT(num line / 2) - 5, 40 - Y TO ;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; INT(num line / 2) + 4, 40 + Y &amp;border</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF shad_box</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO Shadow WITH INT(num line / 2) - 5, 40 - Y, INT(num_line / 2) + 4, 40 + Y, .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE WINDOW Dial_box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;SET COLOR OF NORMAL TO &amp;new_color</span></p>
<p><span class=rvts6>&nbsp; &nbsp;SET COLOR OF MESSAGES TO &amp;new_color</span></p>
<p><span class=rvts6>&nbsp; &nbsp;CLEAR</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine the type of buttons requested and set appropriate parameters.&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* These are representative of some of the ones commonly used in Windows</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* applications. &nbsp;They could easily be modified to suit your own needs.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " &nbsp;OK &nbsp;"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] =" &nbsp; OK &nbsp; "</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2]= " CANCEL "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but type = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " ABORT &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " RETRY &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[3] = " IGNORE "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " &nbsp;YES &nbsp; "</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " &nbsp; NO &nbsp; "</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[3] = " CANCEL "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 4</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " &nbsp;YES &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " &nbsp;NO &nbsp; "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE but_type = 5</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num_but = 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[1] = " RETRY &nbsp;"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button[2] = " CANCEL "</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Get dialog box length to create a bar menu of appropriate size.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Define the bar menu in a do loop. &nbsp;Deactivate the menu upon selection of</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* one of the buttons.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;cnt = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;basex = box_len/(num_but + 1)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DEFINE MENU dial_sel</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE cnt &lt;= num_but</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; style = "DOUBLE"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; pad_name = "PAD " + STR(cnt, 1)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; y_col = (cnt * basex) - (INT(LEN(button[cnt]) / 2))</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DEFINE PAD &amp;pad_name OF dial_sel PROMPT button[cnt] AT 4, y_col</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; * If shadow boxes are set, make sure the buttons appear with shadows as well.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; IF shad_box</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DO SHADOW WITH 3, y_col - 2, 5, y_col + (LEN(button[cnt])) - 1, .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ 3, y_col - 1 TO 5, y_col + (LEN(button[cnt]))</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ON SELECTION PAD &amp;pad_name OF dial_sel DEACTIVATE MENU</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; cnt = cnt +1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Determine correct location to place the message (i.e., centered in the box).</span></p>
<p><span class=rvts6>&nbsp; &nbsp;msg_loc = INT(box_len / 2) - INT(msg_len / 2)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 1, msg_loc SAY msg</span></p>
<p><span class=rvts6>&nbsp; &nbsp;cnt = 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Move the cursor to the default button as passed by the user.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE cnt &lt; but_def</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; KEYBOARD CHR(4)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; cnt = cnt +1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Activate the dialog box and return the button name</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE MENU Dial_sel</span></p>
<p><span class=rvts6>&nbsp; &nbsp;value = TRIM(LTRIM(PROMPT()))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Deactivate dialog box, restore screen and environment, and get rid of</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* shadow. &nbsp;Here we return the text located on the button. &nbsp;We could easily</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* return the number of the button as well.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DEACTIVATE WINDOW Dial box</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF shad box</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO Shadow WITH INT(num_line / 2) - 5, 40 - y, INT(num_line / 2) + 5, 40 + y, .F.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RESTORE SCREEN FROM Backscreen</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ON KEY LABEL TAB</span></p>
<p><span class=rvts6>RETURN value</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE Shadow</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER x1, y1, x2, y2, OnOff</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* If shadowing is on, use the black shadow, otherwise clear box to normal</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* screen colors</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF onoff = .F.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; normal = LEFT(SET("ATTRIBUTES"), AT(",", SET("ATTRIBUTES")) - 1)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; normal = "n+/n"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lnx = x2 + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lny = y2 + 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lndx = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;lndy = (y2-y1) / (x2-x1)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Draw Box using @...FILL and appropriate color.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE lnx &lt;&gt; x1 .OR. lny &lt;&gt; y1+2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ lnx, lny FILL TO x2 + 1, y2 + 2 COLOR &amp;normal</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; lnx = IIF(lnx &lt;&gt; x1, lnx - lndx, lnx)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; lny = IIF(lny &lt;&gt; y1 + 2, lny - lndy, lny)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; lny = IIF(lny &lt; y1 + 2, y1 + 2, lny)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>3 &nbsp; Dressing Up the Data by Eric Schlueter</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Dressing Up the Data</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Erik Schlueter</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Have you found yourself in a corner after having placed too much information</span></p>
<p><span class=rvts6>in one field and found you needed to break it out into separate fields?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>We are often faced with the task of converting existing data to a different</span></p>
<p><span class=rvts6>case or to split data into several fields. &nbsp;Take, for example, a poorly</span></p>
<p><span class=rvts6>designed database consisting of three fields for all the data used in mailing</span></p>
<p><span class=rvts6>labels. &nbsp;The beginning file structure is:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Field &nbsp;Field Name &nbsp;Type &nbsp; &nbsp; &nbsp; Width &nbsp; &nbsp;Dec &nbsp; &nbsp;Index</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 1 &nbsp;LINE1 &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 35 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 2 &nbsp;LINE2 &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 3 &nbsp;LINE3 &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The data for this file called FIRST.DBF is as follows:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Record# &nbsp;LINE1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LINE2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LINE3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; 1 &nbsp;john smith &nbsp; &nbsp; &nbsp; 123 s. main st. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; torrance, ca 90502 &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; 2 &nbsp;AMY SMITH &nbsp; &nbsp; &nbsp; &nbsp;321 OAK DRIVE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LONG BEACH, CA 90550 &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; 3 &nbsp;William Jones &nbsp; &nbsp;20101 Hamilton Avenue &nbsp; &nbsp; Gardena, Ca. 90248-0100 &nbsp;&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>There were also no case rules applied to data entry, so some records are all</span></p>
<p><span class=rvts6>upper-case, some all lower and some leading caps. &nbsp;The objective is to convert</span></p>
<p><span class=rvts6>the database data to all leading caps with the following field structure:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Field &nbsp;Field Name &nbsp;Type &nbsp; &nbsp; &nbsp; Width &nbsp; &nbsp;Dec &nbsp; &nbsp;Index</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 1 &nbsp;LName &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 2 &nbsp;FName &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 3 &nbsp;Address &nbsp; &nbsp; Character &nbsp; &nbsp; 35 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 4 &nbsp;City &nbsp; &nbsp; &nbsp; &nbsp;Character &nbsp; &nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 5 &nbsp;State &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 6 &nbsp;Zip &nbsp; &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>It is always a good practice to work with copies of the data rather than the</span></p>
<p><span class=rvts6>original database. &nbsp;Our first steps will be to create a Second database by</span></p>
<p><span class=rvts6>copying the structure of First to Second, and then modifying the structure of</span></p>
<p><span class=rvts6>Second to include the additional fields shown immediately above (ultimately we</span></p>
<p><span class=rvts6>will create a third database with only those six fields). &nbsp;When modifying the</span></p>
<p><span class=rvts6>structure, you can either insert the new fields wherever you want them or</span></p>
<p><span class=rvts6>place them at the end of the structure list. &nbsp;Then append the records from the</span></p>
<p><span class=rvts6>FIRST database. &nbsp;The commands we issue at the dot prompt are as follows:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.USE First</span></p>
<p><span class=rvts6>.COPY STRUCTURE TO Second</span></p>
<p><span class=rvts6>.USE Second</span></p>
<p><span class=rvts6>.MODIFY STRUCTURE</span></p>
<p><span class=rvts6>* Add FName, LName, Address, City, State, Zip</span></p>
<p><span class=rvts6>.APPEND FROM First</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The next steps involve putting the first name data into the FName field and</span></p>
<p><span class=rvts6>the last name data into the LName field. &nbsp;The source field for this data is</span></p>
<p><span class=rvts6>Line1. &nbsp;To accomplish this we will use the REPLACE command in conjunction with</span></p>
<p><span class=rvts6>the SUBSTR() and AT() functions. &nbsp;The simplest way to move the data from Line1</span></p>
<p><span class=rvts6>to the FName and LName fields would be to:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>REPLACE ALL LName WITH LINE1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>and then delete out the first name data from the LName field. &nbsp;This would be</span></p>
<p><span class=rvts6>tedious if you had many records and you would have to perform a similar</span></p>
<p><span class=rvts6>operation on the first name field. &nbsp;A more elegant solution is to use</span></p>
<p><span class=rvts6>functions to specify the exact characters you want copied into the new</span></p>
<p><span class=rvts6>fields. &nbsp;First, let's look at the whole command:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL LName WITH SUBSTR(Line1, AT(" ", Line1) + 1)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The syntax for the functions used in our case is:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>SUBSTR(&lt;field to pull from&gt;, &lt;starting character position&gt;,</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; [&lt;number of characters&gt;])</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AT(&lt;character to hunt for&gt;,&lt;field to hunt in&gt;)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The data looks like this:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; Record# &nbsp;Line1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp;john smith &nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>By studying the REPLACE command with the correct syntax we can see that the</span></p>
<p><span class=rvts6>field we are pulling from is Line1. &nbsp;The starting position might vary because</span></p>
<p><span class=rvts6>first names aren't all the same length. &nbsp;But, we know that in our database,</span></p>
<p><span class=rvts6>the last name follows the first occurrence of a space in the Line1 field. &nbsp;So</span></p>
<p><span class=rvts6>we use this information to locate the character position where we want to</span></p>
<p><span class=rvts6>start copying. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The SUBSTR() function requires a start position so we can use the AT()</span></p>
<p><span class=rvts6>function to return that number. &nbsp;Our starting position is on the character</span></p>
<p><span class=rvts6>immediately following the space. &nbsp;The AT() function will return the position</span></p>
<p><span class=rvts6>of the space and all we need do is add 1 to that number.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The third parameter (optional) is the "number of characters." If left blank,</span></p>
<p><span class=rvts6>dBASE IV will assume that we want the rest of the characters in the field.&nbsp;</span></p>
<p><span class=rvts6>The REPLACE command takes whatever results from the expression following the</span></p>
<p><span class=rvts6>"WITH" and puts it in the field specified. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The command line to fill the first name field with the information we want is</span></p>
<p><span class=rvts6>very similar to the one just completed:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL FName WITH SUBSTR(Line1, 1, AT(" ",Line1)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The major difference here is we know we want to start at character position</span></p>
<p><span class=rvts6>one, but we can't say for sure what the number of characters will be since</span></p>
<p><span class=rvts6>first name lengths will vary. &nbsp;We do know that the first name is followed by a</span></p>
<p><span class=rvts6>space. If we count from the first character position to the space, that number</span></p>
<p><span class=rvts6>always equals the character position number returned by the AT() function</span></p>
<p><span class=rvts6>hunting for the first space. &nbsp;This sounds like it should be to obvious to</span></p>
<p><span class=rvts6>mention, but if the starting character is not the first, you must subtract the</span></p>
<p><span class=rvts6>starting position from the character position number returned by the AT()</span></p>
<p><span class=rvts6>function to give you the "number of characters" value you need for the third</span></p>
<p><span class=rvts6>parameter of the SUBSTR() function.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>At this point you might want to check your progress by entering the following</span></p>
<p><span class=rvts6>at the dot prompt:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.LIST LName, FName, Line1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Our next challenge is to parse (that's a tech-ese term for breaking up into</span></p>
<p><span class=rvts6>smaller parts) Line3 which consists of city followed by a comma, the two</span></p>
<p><span class=rvts6>letter abbreviation for state and then a zip code which might be either the 5</span></p>
<p><span class=rvts6>number zip or zip plus 4. &nbsp;The contents of the Line3 field for record 1 is</span></p>
<p><span class=rvts6>shown below:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; Record# &nbsp;LINE3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp;torrance, ca 90502 &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Doing the replace command for the city and state fields uses almost exactly</span></p>
<p><span class=rvts6>the same syntax we used for the first name and last name fields. &nbsp;These</span></p>
<p><span class=rvts6>command lines are shown below:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL City WITH SUBSTR(Line3, 1, AT(",", Line3) - 1)</span></p>
<p><span class=rvts6>.REPLACE ALL State WITH SUBSTR(Line3, AT(",", Line3) + 2, 2)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In doing the replace for the City field we cannot use the space as we did</span></p>
<p><span class=rvts6>before because cities can have more than one word in their name (such as Long</span></p>
<p><span class=rvts6>Beach or Cardiff by the Sea). &nbsp;Instead we locate using the comma because we</span></p>
<p><span class=rvts6>know that the first comma marks the end of the city name. &nbsp;We subtract one</span></p>
<p><span class=rvts6>from this location number because we do not want to put the comma into the</span></p>
<p><span class=rvts6>City field. &nbsp;The REPLACE for the State field uses the comma as the locator</span></p>
<p><span class=rvts6>again, but this time we know that the state field begins two characters to the</span></p>
<p><span class=rvts6>right of the comma, so we locate the comma and add two. &nbsp;The State field is</span></p>
<p><span class=rvts6>two characters wide, so the number of characters for the third field will</span></p>
<p><span class=rvts6>always be two.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The next problem is zip code and how to locate its position within LINE3. &nbsp;It</span></p>
<p><span class=rvts6>could be done with a short program, but we would like to keep this part</span></p>
<p><span class=rvts6>confined to the dot prompt commands. &nbsp;The problem is we can't be sure that the</span></p>
<p><span class=rvts6>zip code begins at a predictable number of columns to the right of that comma</span></p>
<p><span class=rvts6>we used to exctract the City and State fields. &nbsp;In one of our data fields we</span></p>
<p><span class=rvts6>notice that a period follows the State field. &nbsp;That period would throw the zip</span></p>
<p><span class=rvts6>code data one position to the right of where the zip code would start for the</span></p>
<p><span class=rvts6>other data. &nbsp;One way to deal with this is to eliminate the city data from the</span></p>
<p><span class=rvts6>Line3 field. &nbsp;Shown below are the command line and the syntax for the new</span></p>
<p><span class=rvts6>functions used:&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL Line3 WITH STUFF(Line3, 1, LEN(TRIM(City)) + 2, "")</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>STUFF(field to be stuffed, start position, number of characters, text to be</span></p>
<p><span class=rvts6>stuffed into the field)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>LEN(&lt;character expression&gt;)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>TRIM(&lt;character expression&gt;)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Ordinarily, the STUFF() function is used to put text into a given position</span></p>
<p><span class=rvts6>within a field, but if the "text to be stuffed into the field" is a null (""),</span></p>
<p><span class=rvts6>then the STUFF() function will remove number of characters from field to be</span></p>
<p><span class=rvts6>stuffed starting at start position. &nbsp;We know the field to be stuffed is the</span></p>
<p><span class=rvts6>Line3 field. &nbsp;We know the start position is 1. &nbsp;So now all we need to know is</span></p>
<p><span class=rvts6>how many characters we need to remove. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>For each record, the City field has already been filled in. &nbsp;If we measure the</span></p>
<p><span class=rvts6>length of the City field, it would tell us how many characters long the city</span></p>
<p><span class=rvts6>name is for that individual record. &nbsp;The LEN() function returns the length of</span></p>
<p><span class=rvts6>a field as a numeric value. &nbsp;Perfect (almost). &nbsp;The LEN() function returns the</span></p>
<p><span class=rvts6>length of the data in the field plus all the trailing blanks. &nbsp;To eliminate</span></p>
<p><span class=rvts6>the trailing blanks, we use the TRIM() function. &nbsp;The expression</span></p>
<p><span class=rvts6>"LEN(TRIM(City))" will give us the number of characters in the City field for</span></p>
<p><span class=rvts6>each record. &nbsp;We also want to get rid of the comma and the space following the</span></p>
<p><span class=rvts6>comma from the Line3 field. &nbsp;This is done by adding 2 to the LEN(TRIM())</span></p>
<p><span class=rvts6>expression. &nbsp;After performing this command line, take a listing of the Line3</span></p>
<p><span class=rvts6>field and see for yourself that the city data has been removed from the</span></p>
<p><span class=rvts6>field. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>We are now ready to copy the zip code information into the Zip field. &nbsp;That</span></p>
<p><span class=rvts6>command line is as follows:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL Zip WITH SUBSTR(Line3, AT(" ", Line3) + 1)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Note that we are now able to use the space as a locator in the AT() function</span></p>
<p><span class=rvts6>expression. &nbsp;This finishes everything we need to do with Line3. &nbsp;We can now</span></p>
<p><span class=rvts6>turn our attention to Line2 where we could quite easily just issue the</span></p>
<p><span class=rvts6>command:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>REPLACE ALL Address WITH Line2</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>but we also need to convert the entire Address field to lower case so that a</span></p>
<p><span class=rvts6>later operation will be able to work with the data more easily. &nbsp;The command</span></p>
<p><span class=rvts6>line we want to use at this time is:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>REPLACE ALL Address WITH LOWER(Line2)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The syntax for this function is:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;LOWER(&lt;Character Expression&gt;)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The LOWER() function converts all alphabetical characters to lower case. &nbsp;This</span></p>
<p><span class=rvts6>is in preparation for converting the data to leading caps.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>At this point, all the data has been parsed out to their respective fields</span></p>
<p><span class=rvts6>from fields Line1, Line2 and Line3. &nbsp;The next task is to convert the data to</span></p>
<p><span class=rvts6>initial caps. &nbsp;The following command lines show how to do this for the FName</span></p>
<p><span class=rvts6>and LName:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL FName WITH UPPER(SUBSTR(FName, 1, 1) + LOWER(SUBSTR(FName, 2)</span></p>
<p><span class=rvts6>.REPLACE ALL LName WITH UPPER(SUBSTR(LName, 1, 1) + LOWER(SUBSTR(LName, 2)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In the above command lines, we are taking the very first character in the</span></p>
<p><span class=rvts6>field and converting it to uppercase in the first part of the WITH expression,</span></p>
<p><span class=rvts6>and then taking the rest of the field and converting it to lowercase in the</span></p>
<p><span class=rvts6>second part of the WITH expression. &nbsp;The plus sign concatenates the two</span></p>
<p><span class=rvts6>parts. &nbsp;Note that dBASE IV has no difficulty taking data from a field,</span></p>
<p><span class=rvts6>manipulating it and then putting it back into the same field, all in one step.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The next field we want to convert is the State field. &nbsp;It is customary to have</span></p>
<p><span class=rvts6>two letter state abbreviations be in all caps. &nbsp;To accomplish this the command</span></p>
<p><span class=rvts6>line would be:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.REPLACE ALL State WITH UPPER(State)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The last fields to convert to leading caps are the Address and City fields.&nbsp;</span></p>
<p><span class=rvts6>In both of these fields, there exists the possibility of having several words</span></p>
<p><span class=rvts6>that require leading caps. &nbsp;In order to deal with all the possibilities we</span></p>
<p><span class=rvts6>must write a small program that walks through the field and finds the spaces.&nbsp;</span></p>
<p><span class=rvts6>It then converts the alphabetical characters following the space to</span></p>
<p><span class=rvts6>uppercase. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* LeadCaps.PRG for the Address field</span></p>
<p><span class=rvts6>GOTO TOP</span></p>
<p><span class=rvts6>DO WHILE .NOT. EOF()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;REPLACE Address WITH UPPER(SUBSTR(Address, 1, 1)) + LOWER(SUBSTR(Address, 2, 34))</span></p>
<p><span class=rvts6>&nbsp; &nbsp;x = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE x &lt; 34</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; IF SUBSTR(Address, x, 1) = CHR(32)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;REPLACE Address WITH;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STUFF(Address, x + 1, 1, UPPER(SUBSTR(Address, x+1, 1)))</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; x = x + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp;SKIP</span></p>
<p><span class=rvts6>ENDDO</span></p>
<p><span class=rvts6>* EOF: LeadCaps.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The same program with minor modifications can be used to convert the City</span></p>
<p><span class=rvts6>field to leading caps. &nbsp;Simply substitute the word City for the word Address.&nbsp;</span></p>
<p><span class=rvts6>And substitute the number 17 for the number 34. &nbsp;The field width of Address is</span></p>
<p><span class=rvts6>35. The number we want to use is n-1 or 34. &nbsp;So the width of the City field is</span></p>
<p><span class=rvts6>18, the number 17 should be used for the loop control.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The final act is to copy the six fields we want to keep to the Third</span></p>
<p><span class=rvts6>database. &nbsp;We could just "COPY TO Third" and then modify the structure and</span></p>
<p><span class=rvts6>delete the fields Line1, Line2 and Line3, but there is a more elegant</span></p>
<p><span class=rvts6>solution:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>.COPY STRUCTURE TO THIRD FIELDS LName, FName, Address, City, State, Zip</span></p>
<p><span class=rvts6>.USE Third</span></p>
<p><span class=rvts6>.DISPLAY STRUCTURE</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Structure for database: C:\DB4\THIRD.DBF</span></p>
<p><span class=rvts6>Number of data records: &nbsp; &nbsp; &nbsp; 3</span></p>
<p><span class=rvts6>Date of last update &nbsp; : 09/14/91</span></p>
<p><span class=rvts6>Field &nbsp;Field Name &nbsp;Type &nbsp; &nbsp; &nbsp; Width &nbsp; &nbsp;Dec &nbsp; &nbsp;Index</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 1 &nbsp;LName &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 2 &nbsp;FName &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 3 &nbsp;Address &nbsp; &nbsp; Character &nbsp; &nbsp; 35 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 4 &nbsp;City &nbsp; &nbsp; &nbsp; &nbsp;Character &nbsp; &nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 5 &nbsp;State &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>&nbsp; &nbsp; 6 &nbsp;Zip &nbsp; &nbsp; &nbsp; &nbsp; Character &nbsp; &nbsp; 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N</span></p>
<p><span class=rvts6>** Total ** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;96</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The data for the Third database should now look like the following:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp;FName &nbsp; &nbsp;LName &nbsp; Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; City &nbsp; &nbsp; &nbsp; State Zip</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp;John &nbsp; &nbsp; Smith &nbsp; 123 S. Main St &nbsp; &nbsp; &nbsp; &nbsp;Torrance &nbsp; CA &nbsp; &nbsp;90502 &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp;Amy &nbsp; &nbsp; &nbsp;Smith &nbsp; 321 Oak Drive &nbsp; &nbsp; &nbsp; &nbsp; Long beach CA &nbsp; &nbsp;90550 &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp;William &nbsp;Jones &nbsp; 20101 Hamilton Avenue Gardena &nbsp; &nbsp;CA &nbsp; &nbsp;90248-0100&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The Second database has served its purpose and could be deleted at this</span></p>
<p><span class=rvts6>point. &nbsp;The First database might be deleted once you are totally satisfied</span></p>
<p><span class=rvts6>that all the data now resides in the Third database. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>It should be noted that the above methodology is designed to convert a large</span></p>
<p><span class=rvts6>amount of data with the least amount of typing, but it is not perfect. &nbsp;Last</span></p>
<p><span class=rvts6>names containing several capitalized letters must be corrected manually (such</span></p>
<p><span class=rvts6>as O'Malley or DeSilva). &nbsp;Also, many of the procedures and functions</span></p>
<p><span class=rvts6>demonstrated here can be combined, reducing the number of steps and files</span></p>
<p><span class=rvts6>necessary to complete the process.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>4 &nbsp; Q &amp; A</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Calling dBASE IV</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Automatic file activation, zero-padded fields and illegal valuesare on our</span></p>
<p><span class=rvts6>list of questions and answers this month.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Q. Is there a way to call dBASE IV with a database name as a parameter and</span></p>
<p><span class=rvts6>have dBASE IV start with that file active?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A. This can be done within the confines of a .BAT file in combination with a</span></p>
<p><span class=rvts6>start-up program in dBASE IV.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* Calldb.bat</span></p>
<p><span class=rvts6>@ECHO OFF</span></p>
<p><span class=rvts6>CLS</span></p>
<p><span class=rvts6>REM Check for parameter.</span></p>
<p><span class=rvts6>IF %1x==x GOTO error</span></p>
<p><span class=rvts6>REM Set DOS environment variable.</span></p>
<p><span class=rvts6>SET dBASE=%1</span></p>
<p><span class=rvts6>REM Call dBASE IV with startup program.</span></p>
<p><span class=rvts6>DBASE /T Startup</span></p>
<p><span class=rvts6>GOTO end</span></p>
<p><span class=rvts6>:error</span></p>
<p><span class=rvts6>ECHO You must specify the file name you want to open when you are</span></p>
<p><span class=rvts6>ECHO using %0 to start dBASE IV!</span></p>
<p><span class=rvts6>ECHO Syntax: %0 [database file name with extension]</span></p>
<p><span class=rvts6>:end</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* Startup.prg</span></p>
<p><span class=rvts6>SET CONSOLE OFF</span></p>
<p><span class=rvts6>temp = GETENV("dbase") &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Get Dos environment variable.</span></p>
<p><span class=rvts6>SET CONSOLE ON</span></p>
<p><span class=rvts6>IF LEN(TRIM(temp)) = 0 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Check Dos environment variable.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;? CHR(7) + "THE DOS ENVIRONMENT VARIABLE WAS NOT CREATED. &nbsp;" + ;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; "CHECK YOUR ENVIRONMENT SIZE!"</span></p>
<p><span class=rvts6>ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ON ERROR ? CHR(7) + ;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; "The file "+ temp +" is not a database file, or is corrupt!"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF FILE(temp)</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; USE &amp;temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ? CHR(7)+"The file "+temp+" does not exist!"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ON ERROR</span></p>
<p><span class=rvts6>ENDIF</span></p>
<p><span class=rvts6>* &nbsp;If you want to start directly in the Control Center, remove the asterisk</span></p>
<p><span class=rvts6>* &nbsp;from the next line.</span></p>
<p><span class=rvts6>* &nbsp;ASSIST</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>Once you have created both the .BAT file and .PRG, you can then invoke dBASE</span></p>
<p><span class=rvts6>IV with the syntax: &nbsp; &nbsp;&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Calldb &lt;database file name&gt;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This assumes dBASE IV and CalldB.BAT are in the path, that you have enough</span></p>
<p><span class=rvts6>environment space to create another DOS variable, and that the complete</span></p>
<p><span class=rvts6>filename is specified. &nbsp;If dBASE IV is not in the path, you can modify the</span></p>
<p><span class=rvts6>CalldB.BAT file to move you to the correct drive/directory before you execute</span></p>
<p><span class=rvts6>dBASE IV.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This works well for Windows or any other utility that allows you to associate</span></p>
<p><span class=rvts6>a program with an extension. &nbsp;Within Windows you must pre-define the DOS</span></p>
<p><span class=rvts6>variable with the maximum length filename (12 characters). &nbsp;Within the</span></p>
<p><span class=rvts6>AutoExec.BAT file, add a line something like:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>set dbase=filename.ext</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Otherwise, Windows will run out of environment space when you try and create</span></p>
<p><span class=rvts6>the DOS environment variable.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Leading Zeros</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Q. I have a numeric field in my database called Code with a width of 5. &nbsp;I</span></p>
<p><span class=rvts6>want my fields to have leading zeroes, but whenever I put the zeroes before</span></p>
<p><span class=rvts6>the number, they disappear when I save the field. &nbsp;What can I do to save my</span></p>
<p><span class=rvts6>leading zeroes?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A. There are a number of approaches to solving this problem. In the first</span></p>
<p><span class=rvts6>approach, you can keep the field as a numeric field. &nbsp;When printing a dBASE IV</span></p>
<p><span class=rvts6>report form, you can choose the Show Leading Zeroes option from the &nbsp;Picture</span></p>
<p><span class=rvts6>Functions menu when examining the structure of the Code field. &nbsp;Although the</span></p>
<p><span class=rvts6>field itself will still have no leading zeroes, it will display on the report</span></p>
<p><span class=rvts6>with leading zeros. &nbsp;When displaying from within a program, the L function of</span></p>
<p><span class=rvts6>the @..SAY or ? commands will provide for leading zeroes.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The second approach puts leading zeroes in a character field. Create a</span></p>
<p><span class=rvts6>character field called CodeChar with a width of 5. &nbsp;The Code numeric field</span></p>
<p><span class=rvts6>still exists. Execute the following command from the dot prompt to fill the</span></p>
<p><span class=rvts6>CodeChar field with the contents of the Code numeric field will leading</span></p>
<p><span class=rvts6>zeroes:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>REPLACE ALL CodeChar WITH RIGHT("00000" + LTRIM(STR(Code)), 5)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The STR function supplies the character equivalent of the Code field. The</span></p>
<p><span class=rvts6>LTRIM() function removes any leading spaces from the converted Code field. The</span></p>
<p><span class=rvts6>RIGHT() function takes the 5 right-most characters of the expression. If Code</span></p>
<p><span class=rvts6>equals 34, the RIGHT() function will be using the 5 right-most characters of</span></p>
<p><span class=rvts6>0000034, resulting in 00034.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Data Entry is a Crime</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Q. I have a screen form with a memo field in an open window. &nbsp;Whenever I try</span></p>
<p><span class=rvts6>to enter data with this screen form, I get the message "Illegal Value". &nbsp;I've</span></p>
<p><span class=rvts6>also noticed that if I put information on line 22 of the screen form, it</span></p>
<p><span class=rvts6>overwrites the menu on the top of the screen. &nbsp;What do I do to fix these</span></p>
<p><span class=rvts6>problems?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A. The screen form generator creates forms with 22 lines per screen page.&nbsp;</span></p>
<p><span class=rvts6>However, the screen form generator gives no indication that you are crossing a</span></p>
<p><span class=rvts6>page boundary. &nbsp;Row numbers that are evenly divisible by 22 are the boundaries</span></p>
<p><span class=rvts6>of pages and should be avoided (lines 22, 44, 66, 88 and so on).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Therefore, when creating an open window for a memo, keep the memo between</span></p>
<p><span class=rvts6>lines 1 and 21 on page 1, 23 and 43 on page 2, and so on. &nbsp;When placing fields</span></p>
<p><span class=rvts6>and typing text, skip the boundary lines.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>5 &nbsp; SQL Database Recovery by Dan Madoni</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>SQL Database Recovery by Dan Madoni</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Woe betide the user who doesn't tread carefully on the sacred grounds of SQL.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Once there was a dBASE IV user that was using SQL with the Standard Edition of</span></p>
<p><span class=rvts6>dBASE IV. &nbsp;He purchased a copy of Server Edition and when he installed it, it</span></p>
<p><span class=rvts6>overwrote all the SQLHOME references to his SQL databases. &nbsp;This posed a</span></p>
<p><span class=rvts6>serious problem: how do you recover SQL databases? &nbsp;The databases exist on the</span></p>
<p><span class=rvts6>hard drive in the form of subdirectories and the tables exist on the hard</span></p>
<p><span class=rvts6>drive as database files within the subdirectories. &nbsp;The only obstacle is that</span></p>
<p><span class=rvts6>dBASE IV doesn't know how to get to them or manage them. &nbsp;This could happen</span></p>
<p><span class=rvts6>whether or not you are installing Server Edition if you are not wary of each</span></p>
<p><span class=rvts6>step of the installation process.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Before you go trying to piece everything back together, make sure that you</span></p>
<p><span class=rvts6>check Config.DB. &nbsp;The SQLHOME line should equal the SQLHOME subdirectory.&nbsp;</span></p>
<p><span class=rvts6>This is usually a directory called SQLHOME that exists off of the dBASE home</span></p>
<p><span class=rvts6>directory. &nbsp;This is often the simplest solution.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>There are two approaches that I know of to correct this problem. &nbsp;The first is</span></p>
<p><span class=rvts6>quite simple but is not 100% reliable. &nbsp;If you are unable to successfully</span></p>
<p><span class=rvts6>complete the steps in Plan A, proceed to Plan B.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Plan A:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>First, QUIT from dBASE IV and move to your SQL database directory. &nbsp;For</span></p>
<p><span class=rvts6>example, in the example code below, the name of the SQL database is MYDB. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The sequence of commands in Plan A:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>C:\DBASE&gt;CD MYDB</span></p>
<p><span class=rvts6>C:\DBASE\MYDB&gt;MD \TEMP</span></p>
<p><span class=rvts6>C:\DBASE\MYDB&gt;COPY *.* \TEMP</span></p>
<p><span class=rvts6>C:\DBASE\MYDB&gt;DEL \TEMP\SYS*.*</span></p>
<p><span class=rvts6>C:\DBASE&gt;DEL MYDB\*.*</span></p>
<p><span class=rvts6>C:\DBASE&gt;RD MYDB</span></p>
<p><span class=rvts6>SQL. CREATE DATABASE MYDB;</span></p>
<p><span class=rvts6>SQL. RUN COPY \TEMP\*.*</span></p>
<p><span class=rvts6>C:\DBASE\MYDB</span></p>
<p><span class=rvts6>DBDEFINE;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>If the directory does not exist, enter the name of the directory you were in</span></p>
<p><span class=rvts6>when it was created. &nbsp;Move to that directory and try again. &nbsp;Create a</span></p>
<p><span class=rvts6>temporary directory, using the MKDIR (or MD) command in DOS.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This directory will be used to hold backups of table data while some tweaking</span></p>
<p><span class=rvts6>is done. &nbsp;Copy the SQL tables form the database (subdirectory) to the TEMP</span></p>
<p><span class=rvts6>directory and delete everything that is not a data table.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Move one directory down and get rid of the SQL database subdirectory (all</span></p>
<p><span class=rvts6>files beginning with the letters SYS).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Now start dBASE IV and SET SQL ON. &nbsp;At the SQL dot prompt, issue the CREATE</span></p>
<p><span class=rvts6>DATABASE command referencing MYDB.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Copy the database tables from the TEMP directory back into the database</span></p>
<p><span class=rvts6>subdirectory with the RUN COPY command. &nbsp;Make sure to substitute the names in</span></p>
<p><span class=rvts6>the example with the names of your paths where appropriate. &nbsp;Once the files</span></p>
<p><span class=rvts6>have been copied, issue a DBDEFINE command followed by a semi-colon at the SQL</span></p>
<p><span class=rvts6>dot prompt. &nbsp;After some hard drive activity, the restoration of the database</span></p>
<p><span class=rvts6>should be complete. &nbsp;Don't forget to delete the TEMP directory and repeat the</span></p>
<p><span class=rvts6>above steps as necessary for each database.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Plan B:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This method is much more direct since it delves right into the heart of the</span></p>
<p><span class=rvts6>dBASE IV SQL management databases to fix the problem. &nbsp;If you are familiar</span></p>
<p><span class=rvts6>with the methods dBASE IV uses to manage SQL databases and tables, some of the</span></p>
<p><span class=rvts6>following explanation might be old hat.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>When you create an SQL database, you are actually creating a subdirectory</span></p>
<p><span class=rvts6>given the same name as the database. &nbsp;The SQLHOME directory contains a dBASE</span></p>
<p><span class=rvts6>IV database file called SysDbs.DBF which contains information on what</span></p>
<p><span class=rvts6>databases exist and where to find them. &nbsp;If the name of a database is MyDb,</span></p>
<p><span class=rvts6>there would be a subdirectory off whatever directory that MyDb was created and</span></p>
<p><span class=rvts6>an entry in the SysDbs database with the name and path of MyDb.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Inside the MyDb subdirectory, there are several dBASE IV databases that</span></p>
<p><span class=rvts6>contain information on the tables that make up MyDb. &nbsp;The file that is of</span></p>
<p><span class=rvts6>concern is SysTables.DBF. &nbsp;The data tables also reside in this subdirectory as</span></p>
<p><span class=rvts6>dBASE IV databases.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>With this in mind, as long as the subdirectories and data exist in their</span></p>
<p><span class=rvts6>places, we can modify a couple of system DBF files just as we would any other</span></p>
<p><span class=rvts6>DBF and subsequently tell dBASE IV where everything is.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>To do this, start dBASE IV from the directory in which it is installed.&nbsp;</span></p>
<p><span class=rvts6>Proceed to the dot prompt and type:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>SET DIRECTORY TO SQLHOME</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Once in the SQLHOME subdirectory, we can try to manually fix the SysDbs file.&nbsp;</span></p>
<p><span class=rvts6>The sequence of commands shown below goes beyond simply opening the SysDbs and</span></p>
<p><span class=rvts6>making modifications. &nbsp;SysDbs has to be copied to a temporary database since</span></p>
<p><span class=rvts6>it is a Read-Only DBF:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>USE SYSDBS</span></p>
<p><span class=rvts6>COPY TO TEMP</span></p>
<p><span class=rvts6>USE TEMP</span></p>
<p><span class=rvts6>BROWSE</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>There will probably be one entry for the Samples SQL database in this file.&nbsp;</span></p>
<p><span class=rvts6>Notice that the Name field has the name of the Samples database and the Path</span></p>
<p><span class=rvts6>field indicates where it is located. &nbsp;The Creator and Created fields are not</span></p>
<p><span class=rvts6>important for our purposes.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Add a record to the database, typing in the name of the SQL database into the</span></p>
<p><span class=rvts6>Name field, (such as MyDb) and the path where it is located in the Path field,</span></p>
<p><span class=rvts6>(such as C:\DBASE\MYDB). &nbsp;Press Ctrl-End to save the changes made to the Temp</span></p>
<p><span class=rvts6>database and copy it over the old SysDbs as shown below:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>COPY TO SYSDBS</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Close and erase the Temp file:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>USE</span></p>
<p><span class=rvts6>ERASE TEMP.DBF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Now, SET SQL ON and try to START the database:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>START DATABASE MYDB;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>If you are successful, make sure that the tables are still intact by issuing a</span></p>
<p><span class=rvts6>SELECT command, (assume in the following example that the table is called</span></p>
<p><span class=rvts6>"MYTABLE"):</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>SELECT * FROM MYTABLE;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>If you see your data, you can pretty much assume that success has smiled upon</span></p>
<p><span class=rvts6>you. &nbsp;If you get an error indicating that the table does not exist, but the</span></p>
<p><span class=rvts6>DBF files with the table names exist in the subdirectory, type DBDEFINE; at</span></p>
<p><span class=rvts6>the SQL dot prompt:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Read Me Last</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>You may not achieve definitive results by following one of the above plans.&nbsp;</span></p>
<p><span class=rvts6>You may have try a combination of steps from both of them. &nbsp;Hopefully, you</span></p>
<p><span class=rvts6>have acquired an understanding of how dBASE IV manages SQL data. &nbsp;Once you</span></p>
<p><span class=rvts6>have a clear understanding of how it works along with a basic understanding of</span></p>
<p><span class=rvts6>dBASE IV and SQL, you will find that recovering SQL databases is almost always</span></p>
<p><span class=rvts6>possible as long as the tables still exist on the hard drive.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>6 &nbsp; Corrigenda: A Short Course in Weights and Measures</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Corrigenda: A Short Course in Weights and Measures</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In last month's edition of TechNotes we included a utility that made various</span></p>
<p><span class=rvts6>conversions between American and metric weight and fluid measurements (see</span></p>
<p><span class=rvts6>"Weight and Fluid Conversions", October 1991). &nbsp;The vast majority of dBASE IV</span></p>
<p><span class=rvts6>applications revolve around business and, alas, our illiteracy in science</span></p>
<p><span class=rvts6>showed through. &nbsp;Many thanks to Peter Ingreman for pointing out that there</span></p>
<p><span class=rvts6>were many unstated assumptions in the article.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Science-minded folk will no doubt be aware that a kilogram is a measure of</span></p>
<p><span class=rvts6>mass and a pound is a measure of force. &nbsp;You can't really convert one to the</span></p>
<p><span class=rvts6>other knowing only the number of kilograms or pounds. &nbsp;Even if you stay within</span></p>
<p><span class=rvts6>one system (American or metric), you still have problems: you can convert</span></p>
<p><span class=rvts6>fluid to weight only knowing the density of the fluid.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>For all practical purposes (given our penchant for business applications), the</span></p>
<p><span class=rvts6>conversion table presented in the article is valid because most folks not</span></p>
<p><span class=rvts6>involved in pursuits of scientific theory think of things as having a certain</span></p>
<p><span class=rvts6>weight. &nbsp;We want to know how many pounds (or kilograms) we can buy for a</span></p>
<p><span class=rvts6>certain amount of money. &nbsp;We typically don't worry about the assumptions of</span></p>
<p><span class=rvts6>temperature, mass, gravity or density.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>7 &nbsp; Automatically Opening a Memo Window</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In last month's edition, a Q &amp; A entitled "Look, No Hands!" talked about the</span></p>
<p><span class=rvts6>possibility of directly entering &nbsp;EDIT mode when a memo window appears. &nbsp;The</span></p>
<p><span class=rvts6>answer specified use of the READKEY() function, although the UDF that followed</span></p>
<p><span class=rvts6>is conspicuously absent of the use of that function. &nbsp;The reference should</span></p>
<p><span class=rvts6>have been to the LASTKEY() function in the text preceding the code.&nbsp;</span></p>
<p><span class=rvts6>Additionally, it should be noted that this functionality will only be valid</span></p>
<p><span class=rvts6>when using the dBASE editor and not an external editor. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>8 &nbsp; Function Junction</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Function Junction by Adam Menkes</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>We've printed dozens of UDFs, touted their flexibility and power and still.&nbsp;</span></p>
<p><span class=rvts6>Let's review the basics</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>What is a UDF? &nbsp;A User-Defined Function is just that, a function defined by</span></p>
<p><span class=rvts6>you, the user. &nbsp;Although dBASE IV has many functions, there may be times when</span></p>
<p><span class=rvts6>you need something that is not included. &nbsp;For example, if you wanted a</span></p>
<p><span class=rvts6>function that took some date, added seven days to it, and returned the value</span></p>
<p><span class=rvts6>of a new date, your UDF would look something like this :</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION Date7</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER DatePassed</span></p>
<p><span class=rvts6>&nbsp; &nbsp; DatePassed = DatePassed + 7</span></p>
<p><span class=rvts6>RETURN DatePassed</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This function could also be written more concisely, by performing the</span></p>
<p><span class=rvts6>calculation as part of the return value.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION Date7</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER DatePassed</span></p>
<p><span class=rvts6>RETURN DatePassed + 7</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Although this is rather simple function (more aptly, a Useless Defined</span></p>
<p><span class=rvts6>Function), it does give you some foundation for creating them. &nbsp;The first few</span></p>
<p><span class=rvts6>examples can be done just as easily without these functions.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. ? {07/01/91} + 7</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>is exactly the same as</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. ? Date7({07/01/91})</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>and</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. ? CTOD("07/01/91") + 7 &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The statement FUNCTION Date7 names your function, Date7, &nbsp;so that you may call</span></p>
<p><span class=rvts6>it up later. &nbsp;The PARAMETER is what value or values passed to the UDF for the</span></p>
<p><span class=rvts6>calculation. You may have many parameters (10 literal, 50 variable).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>After you perform your calculation, you RETURN a value. This value does not</span></p>
<p><span class=rvts6>have to be the same data type as the parameter passed.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Passing two or more parameters is functionally the same as passing one, it</span></p>
<p><span class=rvts6>just gives more options. For example, you want to create a more generic date</span></p>
<p><span class=rvts6>function that adds some number of days to some date, your new function might</span></p>
<p><span class=rvts6>look like:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION DateX</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER DatePassed, DaysPassed</span></p>
<p><span class=rvts6>RETURN DatePassed + DaysPassed</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Our extra parameter means that we don't have to hard-code the date increment</span></p>
<p><span class=rvts6>value (seven). &nbsp;DateX(DATE(), 7) is the same as Date7(DATE()).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>How do you use these FUNCTIONs?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In your program, format screens, reports, queries, or at the dot prompt you</span></p>
<p><span class=rvts6>may reference your function just as any other dBASE IV function. For example,</span></p>
<p><span class=rvts6>you want to know the date 180 days from today (assume today is 7/1/91),</span></p>
<p><span class=rvts6>combine the dBASE IV DATE() function and our new DateX() UDF:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. Today = DATE()</span></p>
<p><span class=rvts6>07/01/91&nbsp;</span></p>
<p><span class=rvts6>. ? Datex(Today, 180)</span></p>
<p><span class=rvts6>12/28/91</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Nesting Functions</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A lot of confusion occurs when you combine functions. &nbsp;It appears that the</span></p>
<p><span class=rvts6>open and closing parentheses don't always match up. &nbsp;Nesting a function means</span></p>
<p><span class=rvts6>to use a function within a function. &nbsp;As in the example above, DateX(DATE(),</span></p>
<p><span class=rvts6>7) would return the value for today's date plus seven. &nbsp;Since DATE() is a</span></p>
<p><span class=rvts6>function by itself with no parameters, it simply uses an open-end</span></p>
<p><span class=rvts6>close-parenthesis. &nbsp;Since DateX() has 2 parameters, the valid syntax for this</span></p>
<p><span class=rvts6>function is DateX(item1, item2). &nbsp;Therefore, you may not use DateX(item1),</span></p>
<p><span class=rvts6>DateX(), or DateX(n1, n2, n3,.). &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>All dBASE IV functions, including the ones that you write, must be called with</span></p>
<p><span class=rvts6>the correct number of parameters. &nbsp;Further, the parameters must be of the</span></p>
<p><span class=rvts6>right data type and in the right order. &nbsp;In the DateX() function the first</span></p>
<p><span class=rvts6>parameter must be a date and the second parameter must be a number. &nbsp;The</span></p>
<p><span class=rvts6>parameters are separated by commas, so that the correct syntax for</span></p>
<p><span class=rvts6>incrementing today's date by 180 is DateX(DATE(), 180), not DateX(DATE(180)),</span></p>
<p><span class=rvts6>or DateX(DATE())(180) or any of the other increasingly complex combinations of</span></p>
<p><span class=rvts6>parentheses and commas.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A more complex nested functionÄthe dBASE IV function IIF() which takes three</span></p>
<p><span class=rvts6>parametersÄis listed below. &nbsp;See if you can figure out what the possible</span></p>
<p><span class=rvts6>return values might be.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>IIF(Sex = "M", "Male", "Female")</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The IIF() function works with three parameters. &nbsp;The first must evaluate to a</span></p>
<p><span class=rvts6>true or false condition. &nbsp;The second and third parameters are the return</span></p>
<p><span class=rvts6>values. &nbsp;If the first parameter equals true, IIF() will return second</span></p>
<p><span class=rvts6>parameter, else the third parameter is returned. &nbsp;For instance:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>IIF(Sex = "M", "Male", IIF(Sex = "F", "Female", "Neither"))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This statement would translate as: if Sex equals "M", the return value is</span></p>
<p><span class=rvts6>male, otherwise the return value is whatever is after the 2nd comma. &nbsp;This may</span></p>
<p><span class=rvts6>be a little over simplified, but in this nested IIF() example, the implied</span></p>
<p><span class=rvts6>otherwise condition is another IIF(). This second IIF() evaluates (in</span></p>
<p><span class=rvts6>pseudo-code) - to: "if Sex equals F, the return value is Female, otherwise the</span></p>
<p><span class=rvts6>return value is Neither."</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The reason this works is that the second IIF() condition will only be</span></p>
<p><span class=rvts6>evaluated if (or should I say iif) the first condition is false. &nbsp;In this</span></p>
<p><span class=rvts6>case, if the value of Sex is not equal to "M", the second IIF() will be</span></p>
<p><span class=rvts6>disregarded.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>You can also return a value of a different data type. &nbsp;If you had a database</span></p>
<p><span class=rvts6>of numbers 1 to 26 and wanted to convert these to letters, one way you could</span></p>
<p><span class=rvts6>do this is to use:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>IIF(Number = 1, "A", IIF(Number = 2, "B",&nbsp;</span></p>
<p><span class=rvts6>IIF(Number = 3, "C", . IIF(Number = 25, "Y",&nbsp;</span></p>
<p><span class=rvts6>"Z")))))))))))))))))))))))))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Note the 25 right (closing) parentheses. &nbsp;There are not 26 because if the</span></p>
<p><span class=rvts6>first 25 conditions are false, Number = 26 is implied that it must be "Z",</span></p>
<p><span class=rvts6>therefore you don't need to evaluate for that condition. &nbsp;Granted, a logical</span></p>
<p><span class=rvts6>scenario like this is better suited for an array than such a deeply nested</span></p>
<p><span class=rvts6>IIF() statement.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>While there are some differences between a procedure and a functionÄnamely in</span></p>
<p><span class=rvts6>how they're calledÄthe main difference is that a function performs an</span></p>
<p><span class=rvts6>operation and then returns a value, whereas a procedure returns no value.&nbsp;</span></p>
<p><span class=rvts6>There are certain commands you may not do in a function that you can in a</span></p>
<p><span class=rvts6>procedure. &nbsp;See the "Commands" and "Functions" sections of Language Reference</span></p>
<p><span class=rvts6>for more information.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Your library of UDFs become their own overlay that dBASE IV accesses like it</span></p>
<p><span class=rvts6>would its own overlay files. &nbsp;But don't forget: to access this overlay, you</span></p>
<p><span class=rvts6>must SET PROCEDURE TO this file of UDFs. &nbsp;For example, if you saved all your</span></p>
<p><span class=rvts6>PROCEDUREs and FUNCTIONs under the name Library.PRG, you would SET PROCEDURE</span></p>
<p><span class=rvts6>TO Library. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>UDFs can be as simple or as complex as need be. &nbsp;But more importantly, they</span></p>
<p><span class=rvts6>provide an access for you to increase the functionality of your product.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>9 &nbsp; New on the BBS</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>New on the BBS</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Our BBS contains thousands of files, many of which you may find of</span></p>
<p><span class=rvts6>interest.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>dBIINFO.ZIP &nbsp;Several utilities to get information about .DBF, .NDX and .MDX</span></p>
<p><span class=rvts6>files. &nbsp;Reports the number of records in a .DBF file, the number of tags in</span></p>
<p><span class=rvts6>a .MDX, returns the index expression of a .MDX tag and returns the index</span></p>
<p><span class=rvts6>expression of a .NDX file. &nbsp;Works with Framework III/IV as well. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>HPLASER.ZIP &nbsp;When printing to an HP LaserJet II or below in landscape mode,</span></p>
<p><span class=rvts6>you get a page eject before each print job. &nbsp;This is particularly</span></p>
<p><span class=rvts6>irritating to people trying to print envelopes. &nbsp;This is a replacement</span></p>
<p><span class=rvts6>print driver to fix the problem.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>25N1.ZIP &nbsp;A printer driver for the Pacific Data 25-in-1 cartridge</span></p>
<p><span class=rvts6>supporting nearly all fonts.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>All .ZIP files are compressed using PKZIP and require PKUNZIP (also on the</span></p>
<p><span class=rvts6>BBS) for expansion.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>10 &nbsp;Manual Overwrite</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>MANUAL OVERWRITE&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The Fundamentals of &nbsp;Popups</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Understanding the basics of popups opens up great functionality to new dBASE</span></p>
<p><span class=rvts6>IV users.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Among the many additions to the command structure of the dBASE language that</span></p>
<p><span class=rvts6>have appeared in dBASE IV, menu commands are probably the biggest code</span></p>
<p><span class=rvts6>reducers and labor savers. &nbsp;But getting acquainted with popups by trying to</span></p>
<p><span class=rvts6>piece together all of the necessary commands in Language Reference can be a</span></p>
<p><span class=rvts6>difficult learning experience. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>There are basically two types of menus in the dBASE IV language: popups and</span></p>
<p><span class=rvts6>menus. &nbsp;Both operate similarly but are defined differently and have some</span></p>
<p><span class=rvts6>mutually exclusive features. &nbsp;Both are considered "light-bar" menus where you</span></p>
<p><span class=rvts6>use the cursor keys to highlight a desired option that will perform a specific</span></p>
<p><span class=rvts6>task when you press the Enter key. &nbsp;If you've ever had to program one of these</span></p>
<p><span class=rvts6>in dBASE III PLUS, you'll greatly appreciate these additions to the language.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Both are control structures in the sense that once you activate either one, it</span></p>
<p><span class=rvts6>has control of the program until you deactivate it somehow. &nbsp;As a programmer,</span></p>
<p><span class=rvts6>you define what tasks they perform but once you activate them they are in</span></p>
<p><span class=rvts6>control until deactivated.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Popups can be described as "vertical light-bar" menus. &nbsp;You have a box with a</span></p>
<p><span class=rvts6>series of prompts inside of it and you use the up-arrow and down-arrow keys to</span></p>
<p><span class=rvts6>navigate through the available selections. &nbsp;Once you press Enter on an item, a</span></p>
<p><span class=rvts6>pre-defined process is executed.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>There are basically three steps to defining a popup:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>1. Give it a name.</span></p>
<p><span class=rvts6>2. Give it some selectable items.</span></p>
<p><span class=rvts6>3. Assign an action to be performed when any item is selected from the popup.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Corresponding to these three steps are the commands:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>1. &nbsp; &nbsp;DEFINE POPUP</span></p>
<p><span class=rvts6>2. &nbsp; &nbsp;DEFINE BAR</span></p>
<p><span class=rvts6>3. &nbsp; &nbsp;ON SELECTION POPUP</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>To assign the name and properties of a popup, you use the DEFINE POPUP</span></p>
<p><span class=rvts6>command. &nbsp;With this command you must at least specify its name and the</span></p>
<p><span class=rvts6>beginning row and column coordinates that the popup will be displayed in. &nbsp;See</span></p>
<p><span class=rvts6>Language Reference for additional options.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>If you choose to make your popup a field list, a files list, or a structure</span></p>
<p><span class=rvts6>list, the second step, DEFINE BAR will be taken care of for you. &nbsp;A field list</span></p>
<p><span class=rvts6>would prompt you with all the values in a particular field in an active</span></p>
<p><span class=rvts6>database. &nbsp;A files list would prompt you with a list of file names. &nbsp;You can</span></p>
<p><span class=rvts6>limit what files are displayed by supplying a wild card skeleton that the</span></p>
<p><span class=rvts6>files must all match. &nbsp;A structure list would prompt you with all of the field</span></p>
<p><span class=rvts6>names in the structure of an active database or with a list of the fields</span></p>
<p><span class=rvts6>currently in the SET FIELDS list.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>If you didn't make it a field, files, or structure list popup, you need to</span></p>
<p><span class=rvts6>define, bar by bar, what the contents of the highlight bars will be for this</span></p>
<p><span class=rvts6>popup. &nbsp;This is done one at a time with the DEFINE BAR command. &nbsp;Each defined</span></p>
<p><span class=rvts6>bar in a popup must be given a unique number and a prompt. &nbsp;You can optionally</span></p>
<p><span class=rvts6>assign each bar a message to be displayed whenever that bar is highlighted.&nbsp;</span></p>
<p><span class=rvts6>You can define the bar so that it can never be selected or you can specify a</span></p>
<p><span class=rvts6>condition that would need to be true in order for that bar to be</span></p>
<p><span class=rvts6>non-selectable or skipped over with the SKIP FOR clause.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In order for this popup to be able to do any useful work for us, we must tell</span></p>
<p><span class=rvts6>it what to do when we press Enter on one of the selectable prompts. &nbsp;This is</span></p>
<p><span class=rvts6>where the ON SELECTION POPUP command comes in. &nbsp;If you define a popup but</span></p>
<p><span class=rvts6>don't provide an ON SELECTION for it, nothing happens when you press Enter.&nbsp;</span></p>
<p><span class=rvts6>Two of the most common things that are done with the ON SELECTION POPUP</span></p>
<p><span class=rvts6>command are:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* &nbsp; have the popup deactivate itself.</span></p>
<p><span class=rvts6>* &nbsp; branch control of the program to a procedure with a DO CASE structure that</span></p>
<p><span class=rvts6>&nbsp; &nbsp; can handle any of the prompts that may have been selected and, if &nbsp;&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; necessary, deactivate the popup.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>So how can you tell my program what item was selected from the popup menu?&nbsp;</span></p>
<p><span class=rvts6>dBASE IV has two functions for this: PROMPT() and BAR(). &nbsp;PROMPT() returns the</span></p>
<p><span class=rvts6>prompt of the most recently selected popup bar. &nbsp;BAR() returns the bar number</span></p>
<p><span class=rvts6>of the most recently selected popup bar. &nbsp;Both of these work even after the</span></p>
<p><span class=rvts6>popup is deactivated. &nbsp;Now, refer to the code called PopTest1.PRG (the code</span></p>
<p><span class=rvts6>for this and other examples follows this article).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In this program we have a complete popup definition. &nbsp;We give it a name and</span></p>
<p><span class=rvts6>starting coordinates and tell dBASE IV to fill in the bars with file names.&nbsp;</span></p>
<p><span class=rvts6>We also tell dBASE IV to deactivate the popup whenever it has been selected.&nbsp;</span></p>
<p><span class=rvts6>In this way, the popup deactivates itself. &nbsp;But the PROMPT() and BAR()</span></p>
<p><span class=rvts6>functions still remember what item was last selected.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Next, PopTest2 shows a slight variation on the first program that has almost</span></p>
<p><span class=rvts6>the same effect.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In this example, it's more clear how the ACTIVATE POPUP command controls the</span></p>
<p><span class=rvts6>whole program and that it's in control until the popup is deactivated. &nbsp;It is</span></p>
<p><span class=rvts6>very important to understand that the ACTIVATE POPUP command is being executed</span></p>
<p><span class=rvts6>as long as the popup is active. &nbsp;The only thing we are certain of after the</span></p>
<p><span class=rvts6>popup has been deactivated is that is was deactivated. &nbsp;We don't know how. &nbsp;A</span></p>
<p><span class=rvts6>popup can be deactivated in one of three ways:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* &nbsp; pressing the Esc key to abandon the popup,</span></p>
<p><span class=rvts6>* &nbsp; pressing the left or right arrow keys also abandon the popup,</span></p>
<p><span class=rvts6>* &nbsp; issuing the DEACTIVATE POPUP command in some other part of the code.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>So how do we know if the popup was abandoned or selected? &nbsp;We can check for</span></p>
<p><span class=rvts6>the value of LASTKEY() or check the PROMPT() function. &nbsp;If PROMPT() returns a</span></p>
<p><span class=rvts6>null character, nothing was selected. &nbsp;If we want to force a selection from</span></p>
<p><span class=rvts6>the popup, we simply keep re-activating it until the PROMPT() function returns</span></p>
<p><span class=rvts6>something other than a null, as shown in PopTest3.PRG.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Notice the SHOW POPUP command in this example code. &nbsp;The reason we use it here</span></p>
<p><span class=rvts6>is because whenever a popup is abandoned or selected, its image is cleared</span></p>
<p><span class=rvts6>from the screen and whatever was originally on that portion of the screen is</span></p>
<p><span class=rvts6>restored. &nbsp;The SHOW POPUP command puts an image of the popup on the screen.&nbsp;</span></p>
<p><span class=rvts6>Now, when the popup is deactivated or selected, dBASE IV restores the image of</span></p>
<p><span class=rvts6>the popup, making this whole process of forcing a selection look much</span></p>
<p><span class=rvts6>smoother.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A different way to handle the problem of forcing a selection is shown in</span></p>
<p><span class=rvts6>PopTest4.PRG, but this one allows you to select to quit the popup. &nbsp;This is a</span></p>
<p><span class=rvts6>very common way of dealing with flow control through a popup. &nbsp;The main</span></p>
<p><span class=rvts6>routine activates the popup in a loop, making sure that it wasn't aborted</span></p>
<p><span class=rvts6>accidentally. &nbsp;The action that is assigned to be performed when this popup is</span></p>
<p><span class=rvts6>selected is to run a procedure that branches out to different tasks, depending</span></p>
<p><span class=rvts6>on which bar was selected from the popup. &nbsp;But no matter where it branches off</span></p>
<p><span class=rvts6>to, this popup is still active and is expecting to receive back control of the</span></p>
<p><span class=rvts6>program. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Of course, you can have this routine deactivate the popup, as is done in this</span></p>
<p><span class=rvts6>example. &nbsp;When the Quit option is selected, the DEACTIVATE POPUP command is</span></p>
<p><span class=rvts6>issued and the control of the program returns immediately to the command</span></p>
<p><span class=rvts6>immediately after the ACTIVATE POPUP command in the main routine, which is the</span></p>
<p><span class=rvts6>IF command that allows the user to exit the loop if they actually selected an</span></p>
<p><span class=rvts6>item. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In this example, the only way to quit this menu is to choose the Quit option</span></p>
<p><span class=rvts6>that we've defined. &nbsp;If you put a DEACTIVATE POPUP at the end of each of the</span></p>
<p><span class=rvts6>CASE statements, selecting any item would cause it to be deactivated. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Popups really are simple, once you know how they work and how to define them.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>11 &nbsp;Code fo Manual Overwrite</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* PopTest1.PRG</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>DEFINE POPUP Test FROM 5,5 PROMPT FILES</span></p>
<p><span class=rvts6>ON SELECTION POPUP Test DEACTIVATE POPUP</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ACTIVATE POPUP Test</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>? "You selected the file " + PROMPT() + ;</span></p>
<p><span class=rvts6>&nbsp; ", it was bar number " + LTRIM(STR(BAR()))</span></p>
<p><span class=rvts6>* End of PopTest.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* PopTest2.PRG</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>DEFINE POPUP Test FROM 5,5 PROMPT FILES</span></p>
<p><span class=rvts6>ON SELECTION POPUP Test DO PopProc</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ACTIVATE POPUP Test</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* End of main routine</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* Procedure PopProc</span></p>
<p><span class=rvts6>PROCEDURE PopProc</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 5,20 CLEAR TO 6,79</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 5,20 SAY "You selected the file " + PROMPT()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 6,20 SAY &nbsp;"it was bar number " + LTRIM(STR(BAR()))</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* End of PopTest2.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* PopTest3.PRG</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>DEFINE POPUP Test FROM 5,5 PROMPT FILES</span></p>
<p><span class=rvts6>ON SELECTION POPUP Test DEACTIVATE POPUP</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>SHOW POPUP Test</span></p>
<p><span class=rvts6>DO WHILE .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE POPUP Test</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF "" # PROMPT()</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CLEAR</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ 5,20 SAY "You selected the file " + PROMPT()</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ 6,20 SAY "it was bar number " + LTRIM(STR(BAR()))</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; EXIT</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; @ 5,20 SAY "You must select an item with the &lt;Enter&gt; key"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; LOOP</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>ENDDO</span></p>
<p><span class=rvts6>* End of PopTest3.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* PopTest4.PRG</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>DEFINE POPUP Test FROM 5,5</span></p>
<p><span class=rvts6>DEFINE BAR 1 OF Test PROMPT "Popup Header " SKIP</span></p>
<p><span class=rvts6>DEFINE BAR 2 OF Test PROMPT "=============" SKIP</span></p>
<p><span class=rvts6>DEFINE BAR 3 OF Test PROMPT "First Choice "</span></p>
<p><span class=rvts6>DEFINE BAR 4 OF Test PROMPT "Second Choice"</span></p>
<p><span class=rvts6>DEFINE BAR 5 OF Test PROMPT " &nbsp; &nbsp;QUIT &nbsp; &nbsp; "</span></p>
<p><span class=rvts6>ON SELECTION POPUP Test DO PopProc</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>SHOW POPUP Test</span></p>
<p><span class=rvts6>DO WHILE .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE POPUP Test</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF "" # PROMPT()</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; EXIT</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>ENDDO</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* End of main routine</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE PopProc</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE BAR() = 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The first choice was selected, &nbsp;do something</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE BAR() = 4</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The second choice was selected, do something else</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; CASE BAR() = 5</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The Quit bar was chosen, deactivate the popup</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DEACTIVATE POPUP</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* End of PopTest4.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>12 &nbsp;Catching Some Arrays by Adam L. Menkes</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Catching Some Arrays by Adam L. Menkes</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Using the power of UDFs and procedures, arrays become even more powerful.</span></p>
<p><span class=rvts6>One advantage of using arrays for processing data instead of working directly</span></p>
<p><span class=rvts6>with the database is the speed at which the information may be processed.&nbsp;</span></p>
<p><span class=rvts6>When working with a database file, you are limited not only by the speed of</span></p>
<p><span class=rvts6>the processor, but also by the disk access speed of your floppy disk or hard</span></p>
<p><span class=rvts6>drive. &nbsp;With an array, all information is processed in memory without disk</span></p>
<p><span class=rvts6>read/write activity. &nbsp;This is useful if you are working in an environment</span></p>
<p><span class=rvts6>where you do not have access rights to the current drive or directory, or</span></p>
<p><span class=rvts6>simply are limited on disk space. &nbsp;There is no need for file or record</span></p>
<p><span class=rvts6>locking.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Another advantage is being able to mix data types. Array[1] could store a Date</span></p>
<p><span class=rvts6>{12/31/91} while Array[2] might store the character string "New Year's Eve".&nbsp;</span></p>
<p><span class=rvts6>Additionally, there is no need to name "fields". &nbsp;Array[2] = "SMITH" is as</span></p>
<p><span class=rvts6>valid as mName = "SMITH". &nbsp;The difference is that where memory variables are</span></p>
<p><span class=rvts6>name oriented, arrays are position oriented. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A disadvantage with using arrays is that you are limited by available memory</span></p>
<p><span class=rvts6>(RAM) and by dBASE IV limitations: 1,170 elements in version 1.1; 33,554,431</span></p>
<p><span class=rvts6>elements in Server Edition, with no more than 65,535 elements in either</span></p>
<p><span class=rvts6>dimension. However, these are not unreasonable limitations since an array of</span></p>
<p><span class=rvts6>Array[4, 65535] (4 * 65,535 = 262,140 elements) would require over 16</span></p>
<p><span class=rvts6>megabytes of memory (each empty array element allocates 64 bytes).&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Another disadvantage is that once an array is declared, the size is static,</span></p>
<p><span class=rvts6>that is, it can not be changed without losing the contents of the array (the</span></p>
<p><span class=rvts6>size can be dynamic in the Server Edition). &nbsp;Also, you cannot do global</span></p>
<p><span class=rvts6>operations on the array elements, only on one element at a time. &nbsp;The</span></p>
<p><span class=rvts6>functions presented in the following pages allow more flexibility when using</span></p>
<p><span class=rvts6>arrays.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Procedures &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ASort sorts the array elements by the column specified, either ascending or</span></p>
<p><span class=rvts6>descending (Similar to INDEX ON or SORT ON). AFill fills an array with data of</span></p>
<p><span class=rvts6>any type (except MEMO) and is similar to REPLACE ALL. &nbsp;ACopy copies the array</span></p>
<p><span class=rvts6>to another name, similar to COPY TO. &nbsp;ADel, like DELETE and PACK in one</span></p>
<p><span class=rvts6>command, removes an element from an array whereas the PROCEDURE AIns adds an</span></p>
<p><span class=rvts6>element (like APPEND BLANK or INSERT BLANK). &nbsp;AChange will convert a</span></p>
<p><span class=rvts6>one-dimensional array to a two-dimensional array (Adam[10] becomes Adam[1,</span></p>
<p><span class=rvts6>10]) or a row from a two-dimensional array to a one-dimensional one (Adam[x,</span></p>
<p><span class=rvts6>7] becomes Adam[7] where x is any row in the array). &nbsp;AFlip will change the</span></p>
<p><span class=rvts6>ROW/COLUMN orientation to COLUMN/ROW such that Adam[x, y] (Adam[12, 23]) will</span></p>
<p><span class=rvts6>become Adam[y, x] (Adam[23, 12]) without altering the data in these elements.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Functions</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ARows() returns the number of rows in the array by incrementing the array</span></p>
<p><span class=rvts6>until the TYPE() is 'U' (Undefined). &nbsp;If it is a one-dimensional array (for</span></p>
<p><span class=rvts6>example, Adam[20]) there are no rows. &nbsp;If it is a two-dimensional array (like</span></p>
<p><span class=rvts6>Adam[20, 40]), it will return 20. &nbsp;The array name is either passed as a</span></p>
<p><span class=rvts6>literal or a variable:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. totalRow = ARows("Adam") &nbsp; &nbsp;&amp;&amp; passed as a literal.</span></p>
<p><span class=rvts6>. mArray = "Adam" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<p><span class=rvts6>. TotalRow = ARows(mArray) &nbsp; &nbsp;&amp;&amp; passed as a variable.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ACols() returns the number of columns in the array by incrementing the array</span></p>
<p><span class=rvts6>until the TYPE() is 'U' (Undefined). &nbsp;If it is a one-dimensional</span></p>
<p><span class=rvts6>arrayÄAdam[20]Äit will return 20. &nbsp;If it is a two-dimensional arrayÄAdam[20,</span></p>
<p><span class=rvts6>40]Äit will return 40. &nbsp;Uses ARows() to determine whether it is a 1 or 2</span></p>
<p><span class=rvts6>dimensional array.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ASort</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This procedure will sort the elements in an array (1 or 2 dimensional) by the</span></p>
<p><span class=rvts6>column specified. &nbsp;You may sort it in ascending (the default) or descending</span></p>
<p><span class=rvts6>order. &nbsp;All the elements in the specified column do not have to be of the same</span></p>
<p><span class=rvts6>data type, however, it will determine what type to sort based on the data type</span></p>
<p><span class=rvts6>of the last element in the array. &nbsp;All elements of a different data type will</span></p>
<p><span class=rvts6>retain their position. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This procedure starts at the last element of the array and determines whether</span></p>
<p><span class=rvts6>or not there is another element that evaluates to a greater value. &nbsp;If it</span></p>
<p><span class=rvts6>does, it switches the two elements, then evaluates the last element against</span></p>
<p><span class=rvts6>all the others again, continuing this switching until there is no greater</span></p>
<p><span class=rvts6>value in the array. &nbsp;Once it has determined that the last element is indeed</span></p>
<p><span class=rvts6>the greatest value, it begins this same comparison and switch process for the</span></p>
<p><span class=rvts6>second to last element. &nbsp;This continues until it has reached the first element</span></p>
<p><span class=rvts6>(nothing left to compare). &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>In a descending sort, it simply evaluates to the lesser value. &nbsp;Rather than</span></p>
<p><span class=rvts6>writing two separate procedures to handle this, it was easier to pass a</span></p>
<p><span class=rvts6>parameter for ascending or descending (actually, the way it evaluates is</span></p>
<p><span class=rvts6>Descending or not descending). &nbsp;You may also notice that I have reduced the</span></p>
<p><span class=rvts6>code even more by substituting the comparison operator ("&lt;= " and "&gt;=") and</span></p>
<p><span class=rvts6>using macro substitution. &nbsp;Rather than having code that reads:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>IF mAscDesc = "D"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;.Commands&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; IF variable &lt;= other variable</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Commands</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDIF</span></p>
<p><span class=rvts6>ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp;.Commands&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF variable &gt;= other variable</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; .Commands</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>your code reads :</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>IF variable &amp;comparison other variable</span></p>
<p><span class=rvts6>&nbsp; &nbsp;.Commands</span></p>
<p><span class=rvts6>ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AFill</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>When you DECLARE an array, the default is the same as when you declare a</span></p>
<p><span class=rvts6>memory variable PUBLIC or PRIVATE (.F.). &nbsp;With memory variables, you can STORE</span></p>
<p><span class=rvts6>a value TO var1, var2,.varn. With databases, you may REPLACE ALL &lt;Fieldname&gt;</span></p>
<p><span class=rvts6>WITH a value. &nbsp;With the following procedure, you can fill the array with a</span></p>
<p><span class=rvts6>value. &nbsp;It is basically a simple loop, and works with both 1 and 2 dimensional</span></p>
<p><span class=rvts6>arrays. &nbsp;To fill column 4 in array Array1 with "Empty cell", perform the</span></p>
<p><span class=rvts6>following commands:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. mStuff = "Empty cell"</span></p>
<p><span class=rvts6>. DO AFill WITH "Array1", 4, mStuff</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ACopy</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This procedure makes a copy of an array (1 or 2 dimensional). &nbsp;If you have an</span></p>
<p><span class=rvts6>array, Array1[20, 30] and want to copy all the elements to Array2[20, 30],</span></p>
<p><span class=rvts6>simply use :</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>. DO ACopy WITH "Array1", "Array2"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>ADel</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This procedure removes a column from an array (1 or 2 dimensional) and resizes</span></p>
<p><span class=rvts6>the array. &nbsp;For example, if Adam[1] = 1, Adam[2] = 2, Adam[3] = 3, and the</span></p>
<p><span class=rvts6>command DO ADel WITH "Adam", 2 were issued, the results with DISPLAY MEMORY</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;would show: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instead of: &nbsp; &nbsp; &nbsp; &nbsp; or:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;Adam[1] &nbsp;N &nbsp; 1 &nbsp; &nbsp; &nbsp; Adam[1] &nbsp;N &nbsp; 1 &nbsp; &nbsp; &nbsp; Adam[1] &nbsp;N &nbsp; 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;Adam[2] &nbsp;N &nbsp; 3 &nbsp; &nbsp; &nbsp; Adam[2] &nbsp;L &nbsp;.F. &nbsp; &nbsp; &nbsp;Adam[2] &nbsp;N &nbsp; 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Adam[3] &nbsp;N &nbsp; 3 &nbsp; &nbsp; &nbsp; Adam[3] &nbsp;L &nbsp;.F.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Although this is different than the way other software products handle</span></p>
<p><span class=rvts6>deleting an element from an array, this method should perform as if it were</span></p>
<p><span class=rvts6>deleting a record in a database and subsequently packing it since it would be</span></p>
<p><span class=rvts6>easy to use Adam[2] = .F.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AIns</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AIns, which inserts an element into a 1 or 2 dimensional array, is similar to</span></p>
<p><span class=rvts6>ADel in how it works. &nbsp;AIns copies data to a temporary array, adds a column</span></p>
<p><span class=rvts6>instead of removing one, and copies the data back, leaving the inserted column</span></p>
<p><span class=rvts6>blank (.F.).&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AChange</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Procedure AChange will convert a one-dimensional array into a two-dimensional</span></p>
<p><span class=rvts6>array, and vice versa. &nbsp;Given the following 2 arrays:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[3] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 3]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[1] &nbsp;N &nbsp; 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[1, 1] &nbsp;N &nbsp; 1</span></p>
<p><span class=rvts6>Array1[2] &nbsp;N &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[1, 2] &nbsp;N &nbsp; 2&nbsp;</span></p>
<p><span class=rvts6>Array1[3] &nbsp;N &nbsp; 30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[1, 3] &nbsp;N &nbsp; 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 1] &nbsp;N &nbsp; 4</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 2] &nbsp;N &nbsp; 5</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 3] &nbsp;N &nbsp; 6</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>DO AChange WITH "Array1", 1 | WITH "Array2", 1 | WITH "Array2", 2</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>will result as follows :</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[1, 3] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Array2[3] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[3]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[1, 1] &nbsp; N &nbsp; 10 &nbsp; &nbsp; &nbsp;Array2[1] &nbsp;N &nbsp; 1 &nbsp; &nbsp; Array2[1] &nbsp;N &nbsp; 4</span></p>
<p><span class=rvts6>Array1[1, 2] &nbsp; N &nbsp; 20 &nbsp; &nbsp; &nbsp;Array2[2] &nbsp;N &nbsp; 2 &nbsp; &nbsp; Array2[2] &nbsp;N &nbsp; 5</span></p>
<p><span class=rvts6>Array1[1, 3] &nbsp; N &nbsp; 30 &nbsp; &nbsp; &nbsp;Array2[3] &nbsp;N &nbsp; 3 &nbsp; &nbsp; Array2[3] &nbsp;N &nbsp; 6</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AFlip</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>AFlip will "flip" an array, that is, switch the rows and columns. &nbsp;A</span></p>
<p><span class=rvts6>one-dimensional array will become a two-dimensional array and then the rows</span></p>
<p><span class=rvts6>and columns will be switched (notice that Array1 has the elements [1, 1], [2,</span></p>
<p><span class=rvts6>1], and [3, 1] instead of [1, 1], [1, 2], and [1, 3]. &nbsp;This procedure allows</span></p>
<p><span class=rvts6>for data to be evaluated row-wise instead of column-wise without having to</span></p>
<p><span class=rvts6>write more UDFs. &nbsp;This is similar to the way COPY STRUCTURE EXTENDED works by</span></p>
<p><span class=rvts6>making FIELDS in the source database as "records" in the target database.&nbsp;</span></p>
<p><span class=rvts6>Since the columns in an array are like fields in a database and rows are like</span></p>
<p><span class=rvts6>records, processing record-oriented data is now as simple as processing</span></p>
<p><span class=rvts6>column-oriented data by "flipping" the rows and columns.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[3] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 3]</span></p>
<p><span class=rvts6>Array1[1] &nbsp;N &nbsp; 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[1, 1] &nbsp;N &nbsp; 1</span></p>
<p><span class=rvts6>Array1[2] &nbsp;N &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[1, 2] &nbsp;N &nbsp; 2&nbsp;</span></p>
<p><span class=rvts6>Array1[3] &nbsp;N &nbsp; 30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[1, 3] &nbsp;N &nbsp; 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 1] &nbsp;N &nbsp; 4</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 2] &nbsp;N &nbsp; 5</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 3] &nbsp;N &nbsp; 6</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>DO AFlip with "Array1" &nbsp; &nbsp; DO AFlip with "Array2"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[3, 1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Array2[3, 2]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Array1[1, 1] &nbsp;N &nbsp; 10 &nbsp; &nbsp; &nbsp; Array2[1, 1] &nbsp;N &nbsp; 1</span></p>
<p><span class=rvts6>Array1[2, 1] &nbsp;N &nbsp; 20 &nbsp; &nbsp; &nbsp; Array2[1, 2] &nbsp;N &nbsp; 4&nbsp;</span></p>
<p><span class=rvts6>Array1[3, 1] &nbsp;N &nbsp; 30 &nbsp; &nbsp; &nbsp; Array2[2, 1] &nbsp;N &nbsp; 2</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[2, 2] &nbsp;N &nbsp; 5</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[3, 1] &nbsp;N &nbsp; 3</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Array2[3, 2] &nbsp;N &nbsp; 6</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION ARows</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Returns the number of rows in an array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE TYPE("&amp;a_Array[a_Rows, 1]") &lt;&gt; "U"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a_Rows = a_Rows + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN a_Rows - 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION ACols</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Returns the number of columns in an array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires ARows()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Cols = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE IIF(ARows(a_Array) = 0, TYPE("&amp;a_Array[a_Cols]") &lt;&gt; "U", ;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; TYPE("&amp;a_Array[1, a_Cols]") &lt;&gt; "U")</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a_Cols = a_Cols + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN a_Cols - 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE ASort</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires ARows(), ACols()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Sorts elements in an array, either ascending (default) or descending.&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array, a_Col, mAscDesc</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ascDesc = IIF(UPPER(mAscDesc) = "D", "&lt;=", "&gt;=")</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PRIVATE hold var &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Temporary variable for holding data when switching two elements.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = ARows(a_Array) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; # of Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; # of Column</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; One-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = m_Cols &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; Switch rows and columns</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Cols = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; and set columns = 1.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop1 = "Loop Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Set the looping conditions</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last1 = "Last Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; for a one-dimensional array -</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop2 = "Loop Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Note that 'columns' (rows)&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last2 = "Last Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; are irrelevant.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; Two-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop1 = "Loop Row, a_Col" &nbsp; &nbsp; &nbsp;&amp;&amp; Set the looping conditions</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last1 = "Last Row, a_Col" &nbsp; &nbsp; &nbsp;&amp;&amp; for comparison of the last</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop2 = "Loop Row, Curr Col" &nbsp; &amp;&amp; column and the current one.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last2 = "Last Row, Curr Col"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows &gt; 1 .AND. a_Col &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; loop row = m_Rows</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; last row = m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE Last Row &gt; 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switched = .F.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IF TYPE("&amp;a_Array[&amp;m_Last1]") $ "CNFD"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO WHILE Loop Row &gt;= 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Skip element if it is a different data type.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IF TYPE("&amp;a_Array[&amp;m_Loop1]") &lt;&gt; TYPE("&amp;a_Array[&amp;m_Last1]")</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop Row = loop Row - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *Ä Skip element if it is a lesser (greater) value.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF &amp;a_Array[&amp;m_Last1] &amp;ascDesc &amp;a_Array[&amp;m_Loop1]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop Row = loop Row - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Store element if it is greater (lesser) value to Hold Var.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Replace the current element with the comparative element.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Replace the comparative element with Hold Var and continue.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;curr Col = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DO WHILE curr Col &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hold var = &amp;a_Array[&amp;m_Last2]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;a_Array[&amp;m_Last2] = &amp;a_Array[&amp;m_Loop2]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;a_Array[&amp;m_Loop2] = hold var</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr Col = curr Col + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switched = .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXIT</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IF .NOT. switched</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last Row = Last Row - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä If no elements were switched, it was the largest value, continue.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop row = last row</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE hold var</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: ASort.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AIns</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Inserts an element into an array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS a_Array, a_Col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires AROWS(), ACOLS(), PROCEDURE ACOPY</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Temp = "A_" + LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = ARows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACopy WITH a_Array, a_Temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; One-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Two-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Rows, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Array[&amp;m_declare + 1]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE xCurCol &lt; a_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Array[&amp;mRowCol] = &amp;a_Temp[&amp;mRowCol]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE xCurCol = &nbsp;a_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* DO NOTHING</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE xCurCol &gt; a_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Array[&amp;mRowCol] = &amp;a_Temp[&amp;mRowCol - 1]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: AIns.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE ADel</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*- Deletes element from an array. &nbsp;Requires AROWS(), ACOLS(), PROCEDURE ACOPY</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS a_Array, a_Col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Temp="A_"+ LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*- Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Cols = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; If only 1 column left in the array,</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RELEASE &amp;a_Array &nbsp; &nbsp; &amp;&amp; release it from memory.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACopy WITH a_Array, a_Temp &amp;&amp; Copy the data to another array.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mRowCol="xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; 2-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_declare = "m_Rows, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Array[&amp;m_declare - 1]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Store the contents from the temporary array[Column + 0] back into</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä the original array. &nbsp;If the current column is the deleted one,&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä store the contents of the temporary array[Column + 1].</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Array[&amp;mRowCol] = &amp;a_Temp[&amp;mRowCol + &nbsp;IIF(xCurCol &gt;= a_col, 1, 0)]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: ADel.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AFill</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*- Fills an array with a value. &nbsp;Requires ARows(), ACols()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS a_Array, a_Col, m_Var</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = ARows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; 1-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; NOT "xCurCol".</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; 2-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = a_Col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &amp;a_Array[&amp;mRowCol] = m_Var</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: AFIll.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE ACopy</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*_Copies a one or two dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS m_from, m_to</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PUBLIC &amp;m_to</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(m_from)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(m_from)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RELEASE &amp;m_to</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Rows, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;m_to[&amp;m_declare]</span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;m_to[&amp;mRowCol] = &amp;m_from[&amp;mRowCol]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: ACopy.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AChange</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array, a_Row</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Array name, row of data (irrelevent for 1-dim array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires AROWS(), ACOLS(), PROCEDURE ACOPY</span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_temp = "A_"+ LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mDeclare = "1, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol1 = "xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol2 = "1, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mDeclare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol1 = "a_Row, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol2 = "xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Temp[&amp;mDeclare]</span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &amp;a_Temp[&amp;mRowCol2] = &amp;a_Array[&amp;mRowCol1]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACOPY WITH a_Temp, a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: AChange.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AFlip</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires ARows(), ACols(), procedures AChange, ACopy</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO aChange WITH a_Array, 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Temp="A_"+ LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Temp[m_Cols, m_Rows]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Temp[xCurCol, xCurRow] = &amp;a_Array[xCurRow, xCurCol]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACOPY WITH a_Temp, a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>EOP: AFlip.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>13 &nbsp;Array Code</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION ARows</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Returns the number of rows in an array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE TYPE("&amp;a_Array[a_Rows, 1]") &lt;&gt; "U"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a_Rows = a_Rows + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN a_Rows - 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>FUNCTION ACols</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Returns the number of columns in an array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires ARows()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Cols = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE IIF(ARows(a_Array) = 0, TYPE("&amp;a_Array[a_Cols]") &lt;&gt; "U", ;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; TYPE("&amp;a_Array[1, a_Cols]") &lt;&gt; "U")</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a_Cols = a_Cols + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN a_Cols - 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE ASort</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires ARows(), ACols()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Sorts elements in an array, either ascending (default) or descending.&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array, a_Col, mAscDesc</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ascDesc = IIF(UPPER(mAscDesc) = "D", "&lt;=", "&gt;=")</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PRIVATE hold var &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Temporary variable for holding data when switching two elements.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = ARows(a_Array) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; # of Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; # of Column</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; One-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = m_Cols &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; Switch rows and columns</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Cols = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; and set columns = 1.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop1 = "Loop Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Set the looping conditions</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last1 = "Last Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; for a one-dimensional array -</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop2 = "Loop Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Note that 'columns' (rows)&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last2 = "Last Row" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; are irrelevant.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; Two-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop1 = "Loop Row, a_Col" &nbsp; &nbsp; &nbsp;&amp;&amp; Set the looping conditions</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last1 = "Last Row, a_Col" &nbsp; &nbsp; &nbsp;&amp;&amp; for comparison of the last</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Loop2 = "Loop Row, Curr Col" &nbsp; &amp;&amp; column and the current one.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Last2 = "Last Row, Curr Col"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows &gt; 1 .AND. a_Col &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; loop row = m_Rows</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; last row = m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE Last Row &gt; 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switched = .F.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IF TYPE("&amp;a_Array[&amp;m_Last1]") $ "CNFD"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO WHILE Loop Row &gt;= 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Skip element if it is a different data type.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IF TYPE("&amp;a_Array[&amp;m_Loop1]") &lt;&gt; TYPE("&amp;a_Array[&amp;m_Last1]")</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop Row = loop Row - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *Ä Skip element if it is a lesser (greater) value.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF &amp;a_Array[&amp;m_Last1] &amp;ascDesc &amp;a_Array[&amp;m_Loop1]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop Row = loop Row - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Store element if it is greater (lesser) value to Hold Var.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Replace the current element with the comparative element.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Replace the comparative element with Hold Var and continue.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;curr Col = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DO WHILE curr Col &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hold var = &amp;a_Array[&amp;m_Last2]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;a_Array[&amp;m_Last2] = &amp;a_Array[&amp;m_Loop2]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;a_Array[&amp;m_Loop2] = hold var</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr Col = curr Col + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switched = .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXIT</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IF .NOT. switched</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last Row = Last Row - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä If no elements were switched, it was the largest value, continue.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loop row = last row</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE hold var</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: ASort.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AIns</span></p>
<p><span class=rvts6>&nbsp; &nbsp;* Inserts an element into an array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS a_Array, a_Col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires AROWS(), ACOLS(), PROCEDURE ACOPY</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Temp = "A_" + LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = ARows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACopy WITH a_Array, a_Temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; One-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Two-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Rows, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Array[&amp;m_declare + 1]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DO CASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE xCurCol &lt; a_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Array[&amp;mRowCol] = &amp;a_Temp[&amp;mRowCol]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE xCurCol = &nbsp;a_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* DO NOTHING</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE xCurCol &gt; a_col</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Array[&amp;mRowCol] = &amp;a_Temp[&amp;mRowCol - 1]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDCASE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: AIns.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE ADel</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*- Deletes element from an array. &nbsp;Requires AROWS(), ACOLS(), PROCEDURE ACOPY</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS a_Array, a_Col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Temp="A_"+ LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*- Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Cols = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; If only 1 column left in the array,</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RELEASE &amp;a_Array &nbsp; &nbsp; &amp;&amp; release it from memory.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACopy WITH a_Array, a_Temp &amp;&amp; Copy the data to another array.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mRowCol="xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; 2-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_declare = "m_Rows, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Array[&amp;m_declare - 1]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols - 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä Store the contents from the temporary array[Column + 0] back into</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä the original array. &nbsp;If the current column is the deleted one,&nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*Ä store the contents of the temporary array[Column + 1].</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Array[&amp;mRowCol] = &amp;a_Temp[&amp;mRowCol + &nbsp;IIF(xCurCol &gt;= a_col, 1, 0)]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE &amp;a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: ADel.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AFill</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*- Fills an array with a value. &nbsp;Requires ARows(), ACols()</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS a_Array, a_Col, m_Var</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = ARows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; 1-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; NOT "xCurCol".</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; 2-dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = a_Col</span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &amp;a_Array[&amp;mRowCol] = m_Var</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: AFIll.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE ACopy</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*_Copies a one or two dimensional array.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETERS m_from, m_to</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PUBLIC &amp;m_to</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(m_from)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(m_from)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RELEASE &amp;m_to</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_declare = "m_Rows, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol="xCurRow, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;m_to[&amp;m_declare]</span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;m_to[&amp;mRowCol] = &amp;m_from[&amp;mRowCol]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: ACopy.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AChange</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array, a_Row</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Array name, row of data (irrelevent for 1-dim array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires AROWS(), ACOLS(), PROCEDURE ACOPY</span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_temp = "A_"+ LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mDeclare = "1, m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol1 = "xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol2 = "1, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ELSE</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mDeclare = "m_Cols"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol1 = "a_Row, xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; mRowCol2 = "xCurCol"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Temp[&amp;mDeclare]</span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &amp;a_Temp[&amp;mRowCol2] = &amp;a_Array[&amp;mRowCol1]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACOPY WITH a_Temp, a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>* EOP: AChange.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>PROCEDURE AFlip</span></p>
<p><span class=rvts6>&nbsp; &nbsp;PARAMETER a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Requires ARows(), ACols(), procedures AChange, ACopy</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Rows = aRows(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;m_Cols = ACols(a_Array)</span></p>
<p><span class=rvts6>&nbsp; &nbsp;</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0 .AND. m_Cols = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; RETURN</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF m_Rows = 0</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; m_Rows = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO aChange WITH a_Array, 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;a_Temp="A_"+ LTRIM(STR(INT(RAND(-1) * 1000000), 6))</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;*Ä Create a temporary array to copy the information to.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DECLARE &amp;a_Temp[m_Cols, m_Rows]</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;xCurCol = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO WHILE xCurCol &lt;= m_Cols</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurRow = 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; DO WHILE xCurRow &lt;= m_Rows</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;a_Temp[xCurCol, xCurRow] = &amp;a_Array[xCurRow, xCurCol]</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xCurRow = xCurRow + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; ENDDO</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; xCurCol = xCurCol + 1</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>&nbsp; &nbsp;DO ACOPY WITH a_Temp, a_Array</span></p>
<p><span class=rvts6>&nbsp; &nbsp;RELEASE a_Temp</span></p>
<p><span class=rvts6>RETURN</span></p>
<p><span class=rvts6>EOP: AFlip.PRG</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>14 &nbsp;E T C</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>E T C</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Appending Only Unique Records</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>How do you figure out whether or not new records appended to your master</span></p>
<p><span class=rvts6>database and other tidbits.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>The need sometimes arises for the capability of appending records from another</span></p>
<p><span class=rvts6>database but only those records that don't already exist in the database they</span></p>
<p><span class=rvts6>are appending to. &nbsp;If you can establish some criteria for determining what</span></p>
<p><span class=rvts6>unique means, you can create an index on that expression in the database to be</span></p>
<p><span class=rvts6>appended and use the following technique:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>USE Destiny IN 1&nbsp;</span></p>
<p><span class=rvts6>USE Destiny IN 2 ORDER UniKey AGAIN</span></p>
<p><span class=rvts6>APPEND FROM Source FOR .NOT. SEEK(UniKey, 2)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>UniKey would be the expression that is used to determine uniqueness. &nbsp;For</span></p>
<p><span class=rvts6>example, you only want records that don't have the same first and last names</span></p>
<p><span class=rvts6>already in the current database:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>USE Destiny&nbsp;</span></p>
<p><span class=rvts6>INDEX ON Firstname + Lastname TAG Firstlast</span></p>
<p><span class=rvts6>USE Destiny AGAIN IN 2 ORDER Firstlast</span></p>
<p><span class=rvts6>APPEND FROM Source FOR .NOT. SEEK(Firstname + Lastname, 2)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Buddy, Can You Spare a Quarterly Report?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Quarterly reports are a fact of life. &nbsp;If you're in need of generating reports</span></p>
<p><span class=rvts6>that encompass data from the last three months, here's an efficient way to</span></p>
<p><span class=rvts6>group a report. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>First, index on the date field involved and then use the following as your</span></p>
<p><span class=rvts6>group expression:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>INT((MONTH(Datefield) - 1) / 3)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Where in the Manual?</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>So where do you go to find information on the pagination characteristics of</span></p>
<p><span class=rvts6>laser printer drivers? &nbsp;It's the elusive Appendix F at the end of Language</span></p>
<p><span class=rvts6>Reference. &nbsp;By noting the superscripted numbers that reference footnotes at</span></p>
<p><span class=rvts6>the bottom of page F-4, you should be able to capably track down the printer</span></p>
<p><span class=rvts6>driver for you.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Pagination adjustment is not a requirement of dBASE IV. &nbsp;It is a requirement</span></p>
<p><span class=rvts6>for the printer and is found in the appendices of most laser printer manuals</span></p>
<p><span class=rvts6>that we've ever come across.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Keep in mind that the requirement for using 60 lines is not for all laser</span></p>
<p><span class=rvts6>printers. &nbsp;It is for those laser printers which have a default top and bottom</span></p>
<p><span class=rvts6>margin of 1/2" each. &nbsp;Most laser printers which use a Canon engine have this</span></p>
<p><span class=rvts6>default, most &nbsp;notably, Hewlett-Packard. &nbsp;Thus, the laser printers give ten</span></p>
<p><span class=rvts6>inches of &nbsp;printable space on a page, instead of eleven. &nbsp;At the usual six</span></p>
<p><span class=rvts6>lines per inch, this gives 60 printable lines. &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Note that there is a driver which increases the number of lines printed per</span></p>
<p><span class=rvts6>inch and gives 66 lines in portrait mode and 51 lines in landscape mode.&nbsp;</span></p>
<p><span class=rvts6>HPLas2I.PR2 &nbsp;is recommended in lieu of setting the page length to 60 lines for</span></p>
<p><span class=rvts6>all occasions except the printing of labels.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Constructing a Field List</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Within an application, it is sometimes preferable to give the user the</span></p>
<p><span class=rvts6>capability of constructing their own field list for copying or reporting</span></p>
<p><span class=rvts6>purposes. &nbsp;With the help of popups, you can give your users much more variety</span></p>
<p><span class=rvts6>in obtaining specifically the data they need.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>This routine uses the STRUCTURE option of DEFINE POPUP to define a field list</span></p>
<p><span class=rvts6>from user selection. &nbsp;The DO WHILE loop builds a list of the fields selected</span></p>
<p><span class=rvts6>by the user. &nbsp;For each selection, it adds the field name followed by a comma</span></p>
<p><span class=rvts6>to the list. &nbsp;After the last selection, it strips the final comma and performs</span></p>
<p><span class=rvts6>a COPY FIELDS operation using the defined field list. &nbsp;The program also allows</span></p>
<p><span class=rvts6>the user to select the database file from a popup list.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* FldList.PRG</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>SET DBTRAP OFF</span></p>
<p><span class=rvts6>SET TALK OFF</span></p>
<p><span class=rvts6>SET ECHO OFF</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* Prompt user to select a database file from a popup list.</span></p>
<p><span class=rvts6>DEFINE POPUP FilePop FROM 10,25 TO 18,60 PROMPT FILES LIKE *.DBF</span></p>
<p><span class=rvts6>ON SELECTION POPUP FilePop DEACTIVATE POPUP</span></p>
<p><span class=rvts6>ACTIVATE POPUP FilePop</span></p>
<p><span class=rvts6>USE (PROMPT())</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>* Prompt user to select fields from selected database.</span></p>
<p><span class=rvts6>flds = ""</span></p>
<p><span class=rvts6>DEFINE POPUP FldPop FROM 4,24 TO 17,62 PROMPT STRUCTURE ;</span></p>
<p><span class=rvts6>&nbsp;MESSAGE "Press &nbsp;&lt;Enter to select fields, &lt;Esc&gt; when done"</span></p>
<p><span class=rvts6>ON SELECTION POPUP FldPop DEACTIVATE POPUP</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>DO WHILE .T.</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ACTIVATE POPUP FldPop</span></p>
<p><span class=rvts6>&nbsp; &nbsp;IF "" = PROMPT()</span></p>
<p><span class=rvts6>&nbsp; &nbsp; &nbsp; EXIT</span></p>
<p><span class=rvts6>&nbsp; &nbsp;ENDIF</span></p>
<p><span class=rvts6>&nbsp; &nbsp;flds = flds + TRIM(PROMPT()) + ","</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 18,0 SAY "Fields selected:"</span></p>
<p><span class=rvts6>&nbsp; &nbsp;@ 19,0 SAY flds</span></p>
<p><span class=rvts6>ENDDO</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>RELEASE POPUP FldPop</span></p>
<p><span class=rvts6>flds = SUBSTR(flds, 1, LEN(flds) - 1)</span></p>
<p><span class=rvts6>CLEAR</span></p>
<p><span class=rvts6>SET TALK ON</span></p>
<p><span class=rvts6>COPY FIELDS &amp;flds TO NewFile</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A BROWSE or DISPLAY command could be used in place of a COPY in the last line</span></p>
<p><span class=rvts6>of the above code.&nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Logic Block</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Recently, we heard from a user who was running multiple queries on a</span></p>
<p><span class=rvts6>database. &nbsp;Among the multiple queries, he was doing simple filtering using a</span></p>
<p><span class=rvts6>condition box with expressions such as:</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>STATE = "CA" .OR. STATE = "NV"</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>No matter what he did, this expression or any other expression in a condition</span></p>
<p><span class=rvts6>box using the .OR. operator would return the error message "Syntax Error".&nbsp;</span></p>
<p><span class=rvts6>The query would work fine by placing "CA" and "NV" in different lines under</span></p>
<p><span class=rvts6>the STATE field in the file skeleton, or using .AND. in the condition box, but</span></p>
<p><span class=rvts6>not if the .OR. operator was used.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Checking the environment, rebuilding the database from scratch, and using file</span></p>
<p><span class=rvts6>recovery utilities, were all to no avail. &nbsp;After testing the procedure, it was</span></p>
<p><span class=rvts6>finally discovered that one of the field names was "OR". &nbsp;</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>A conflict in logic within dBASE IV occurs when utilizing fields that are</span></p>
<p><span class=rvts6>reserved words in situations like this. &nbsp;Fields with names such as "T", "F",</span></p>
<p><span class=rvts6>"Y", "N", "AND", or "OR" should be avoided.</span></p>
<p><span class=rvts6></span></p>
</body></html>
